"""
This type stub file was generated by pyright.
"""

from typing import Optional, TYPE_CHECKING, Tuple, Union
from pyglet import gl
from .types import BufferOrBufferProtocol, PyGLuint
from ..types import BufferProtocol
from arcade.gl import Context

if TYPE_CHECKING:
    ...
class Texture2D:
    """
    An OpenGL 2D texture.
    We can create an empty black texture or a texture from byte data.
    A texture can also be created with different datatypes such as
    float, integer or unsigned integer.

    The best way to create a texture instance is through :py:meth:`arcade.gl.Context.texture`

    Supported ``dtype`` values are::

        # Float formats
        'f1': UNSIGNED_BYTE
        'f2': HALF_FLOAT
        'f4': FLOAT
        # int formats
        'i1': BYTE
        'i2': SHORT
        'i4': INT
        # uint formats
        'u1': UNSIGNED_BYTE
        'u2': UNSIGNED_SHORT
        'u4': UNSIGNED_INT

    :param ctx: The context the object belongs to
    :param Tuple[int, int] size: The size of the texture
    :param components: The number of components (1: R, 2: RG, 3: RGB, 4: RGBA)
    :param dtype: The data type of each component: f1, f2, f4 / i1, i2, i4 / u1, u2, u4
    :param data: The texture data (optional). Can be bytes or any object supporting the buffer protocol.
    :param filter: The minification/magnification filter of the texture
    :param wrap_x: Wrap mode x
    :param wrap_y: Wrap mode y
    :param target: The texture type (Ignored. Legacy)
    :param depth: creates a depth texture if `True`
    :param samples: Creates a multisampled texture for values > 0.
                        This value will be clamped between 0 and the max
                        sample capability reported by the drivers.
    :param immutable: Make the storage (not the contents) immutable. This can sometimes be
                           required when using textures with compute shaders.
    :param internal_format: The internal format of the texture
    """
    __slots__ = ...
    _compare_funcs = ...
    _swizzle_enum_to_str = ...
    _swizzle_str_to_enum = ...
    def __init__(self, ctx: Context, size: Tuple[int, int], *, components: int = ..., dtype: str = ..., data: Optional[BufferProtocol] = ..., filter: Optional[Tuple[PyGLuint, PyGLuint]] = ..., wrap_x: Optional[PyGLuint] = ..., wrap_y: Optional[PyGLuint] = ..., target=..., depth=..., samples: int = ..., immutable: bool = ..., internal_format: Optional[PyGLuint] = ..., compressed: bool = ..., compressed_data: bool = ...) -> None:
        ...
    
    def resize(self, size: Tuple[int, int]): # -> None:
        """
        Resize the texture. This will re-allocate the internal
        memory and all pixel data will be lost.
        """
        ...
    
    def __del__(self): # -> None:
        ...
    
    @property
    def ctx(self) -> Context:
        """
        The context this texture belongs to

        :type: :py:class:`~arcade.gl.Context`
        """
        ...
    
    @property
    def glo(self) -> gl.GLuint:
        """
        The OpenGL texture id

        :type: GLuint
        """
        ...
    
    @property
    def compressed(self) -> bool:
        """
        Is this using a compressed format?

        :type: bool
        """
        ...
    
    @property
    def width(self) -> int:
        """
        The width of the texture in pixels

        :type: int
        """
        ...
    
    @property
    def height(self) -> int:
        """
        The height of the texture in pixels

        :type: int
        """
        ...
    
    @property
    def dtype(self) -> str:
        """
        The data type of each component

        :type: str
        """
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        The size of the texture as a tuple

        :type: tuple (width, height)
        """
        ...
    
    @property
    def samples(self) -> int:
        """
        Number of samples if multisampling is enabled (read only)

        :type: int
        """
        ...
    
    @property
    def byte_size(self) -> int:
        """
        The byte size of the texture.

        :type: int
        """
        ...
    
    @property
    def components(self) -> int:
        """
        Number of components in the texture

        :type: int
        """
        ...
    
    @property
    def component_size(self) -> int:
        """
        Size in bytes of each component

        :type: int
        """
        ...
    
    @property
    def depth(self) -> bool:
        """
        If this is a depth texture.

        :type: bool
        """
        ...
    
    @property
    def immutable(self) -> bool:
        """
        Does this texture have immutable storage?

        :type: bool
        """
        ...
    
    @property
    def swizzle(self) -> str:
        """
        str: The swizzle mask of the texture (Default ``'RGBA'``).

        The swizzle mask change/reorder the ``vec4`` value returned by the ``texture()`` function
        in a GLSL shaders. This is represented by a 4 character string were each
        character can be::

            'R' GL_RED
            'G' GL_GREEN
            'B' GL_BLUE
            'A' GL_ALPHA
            '0' GL_ZERO
            '1' GL_ONE

        Example::

            # Alpha channel will always return 1.0
            texture.swizzle = 'RGB1'

            # Only return the red component. The rest is masked to 0.0
            texture.swizzle = 'R000'

            # Reverse the components
            texture.swizzle = 'ABGR'
        """
        ...
    
    @swizzle.setter
    def swizzle(self, value: str): # -> None:
        ...
    
    @property
    def filter(self) -> Tuple[int, int]:
        """Get or set the ``(min, mag)`` filter for this texture.
        These are rules for how a texture interpolates.
        The filter is specified for minification and magnification.

        Default value is ``LINEAR, LINEAR``.
        Can be set to ``NEAREST, NEAREST`` for pixelated graphics.

        When mipmapping is used the min filter needs to be one of the
        ``MIPMAP`` variants.

        Accepted values::

            # Enums can be accessed on the context or arcade.gl
            NEAREST                # Nearest pixel
            LINEAR                 # Linear interpolate
            NEAREST_MIPMAP_NEAREST # Minification filter for mipmaps
            LINEAR_MIPMAP_NEAREST  # Minification filter for mipmaps
            NEAREST_MIPMAP_LINEAR  # Minification filter for mipmaps
            LINEAR_MIPMAP_LINEAR   # Minification filter for mipmaps

        Also see

        * https://www.khronos.org/opengl/wiki/Texture#Mip_maps
        * https://www.khronos.org/opengl/wiki/Sampler_Object#Filtering

        :type: tuple (min filter, mag filter)
        """
        ...
    
    @filter.setter
    def filter(self, value: Tuple[int, int]): # -> None:
        ...
    
    @property
    def wrap_x(self) -> int:
        """
        Get or set the horizontal wrapping of the texture. This decides how textures
        are read when texture coordinates are outside the ``[0.0, 1.0]`` area.
        Default value is ``REPEAT``.

        Valid options are::

            # Note: Enums can also be accessed in arcade.gl
            # Repeat pixels on the y axis
            texture.wrap_x = ctx.REPEAT
            # Repeat pixels on the y axis mirrored
            texture.wrap_x = ctx.MIRRORED_REPEAT
            # Repeat the edge pixels when reading outside the texture
            texture.wrap_x = ctx.CLAMP_TO_EDGE
            # Use the border color (black by default) when reading outside the texture
            texture.wrap_x = ctx.CLAMP_TO_BORDER

        :type: int
        """
        ...
    
    @wrap_x.setter
    def wrap_x(self, value: int): # -> None:
        ...
    
    @property
    def wrap_y(self) -> int:
        """
        Get or set the horizontal wrapping of the texture. This decides how textures
        are read when texture coordinates are outside the ``[0.0, 1.0]`` area.
        Default value is ``REPEAT``.

        Valid options are::

            # Note: Enums can also be accessed in arcade.gl
            # Repeat pixels on the x axis
            texture.wrap_x = ctx.REPEAT
            # Repeat pixels on the x axis mirrored
            texture.wrap_x = ctx.MIRRORED_REPEAT
            # Repeat the edge pixels when reading outside the texture
            texture.wrap_x = ctx.CLAMP_TO_EDGE
            # Use the border color (black by default) when reading outside the texture
            texture.wrap_x = ctx.CLAMP_TO_BORDER

        :type: int
        """
        ...
    
    @wrap_y.setter
    def wrap_y(self, value: int): # -> None:
        ...
    
    @property
    def anisotropy(self) -> float:
        """
        Get or set the anisotropy for this texture.
        """
        ...
    
    @anisotropy.setter
    def anisotropy(self, value): # -> None:
        ...
    
    @property
    def compare_func(self) -> Optional[str]:
        """
        Get or set the compare function for a depth texture::

            texture.compare_func = None  # Disable depth comparison completely
            texture.compare_func = '<='  # GL_LEQUAL
            texture.compare_func = '<'   # GL_LESS
            texture.compare_func = '>='  # GL_GEQUAL
            texture.compare_func = '>'   # GL_GREATER
            texture.compare_func = '=='  # GL_EQUAL
            texture.compare_func = '!='  # GL_NOTEQUAL
            texture.compare_func = '0'   # GL_NEVER
            texture.compare_func = '1'   # GL_ALWAYS

        :type: str
        """
        ...
    
    @compare_func.setter
    def compare_func(self, value: Union[str, None]): # -> None:
        ...
    
    def read(self, level: int = ..., alignment: int = ...) -> bytes:
        """
        Read the contents of the texture.

        :param level:  The texture level to read
        :param alignment: Alignment of the start of each row in memory in number of bytes. Possible values: 1,2,4
        """
        ...
    
    def write(self, data: BufferOrBufferProtocol, level: int = ..., viewport=...) -> None:
        """Write byte data from the passed source to the texture.

        The ``data`` value can be either an
        :py:class:`arcade.gl.Buffer` or anything that implements the
        `Buffer Protocol <https://docs.python.org/3/c-api/buffer.html>`_.

        The latter category includes ``bytes``, ``bytearray``,
        ``array.array``, and more. You may need to use typing
        workarounds for non-builtin types. See
        :ref:`prog-guide-gl-buffer-protocol-typing` for more
        information.

        :param data: :class:`~arcade.gl.Buffer` or
                                            buffer protocol object with
                                            data to write.
        :param level: The texture level to write
        :param Union[Tuple[int, int], Tuple[int, int, int, int]] viewport:
          The area of the texture to write. 2 or 4 component tuple
        """
        ...
    
    def build_mipmaps(self, base: int = ..., max_level: int = ...) -> None:
        """Generate mipmaps for this texture.

        The default values usually work well.

        Mipmaps are successively smaller versions of an original
        texture with special filtering applied. Using mipmaps allows
        OpenGL to render scaled versions of original textures with fewer
        scaling artifacts.

        Mipmaps can be made for textures of any size. Each mipmap
        version halves the width and height of the previous one (e.g.
        256 x 256, 128 x 128, 64 x 64, etc) down to a minimum of 1 x 1.

        .. note:: Mipmaps will only be used if a texture's filter is
                  configured with a mipmap-type minification::

                   # Set up linear interpolating minification filter
                   texture.filter = ctx.LINEAR_MIPMAP_LINEAR, ctx.LINEAR

        :param base: Level the mipmaps start at (usually 0)
        :param max_level: The maximum number of levels to generate

        Also see: https://www.khronos.org/opengl/wiki/Texture#Mip_maps
        """
        ...
    
    def delete(self): # -> None:
        """
        Destroy the underlying OpenGL resource.
        Don't use this unless you know exactly what you are doing.
        """
        ...
    
    @staticmethod
    def delete_glo(ctx: Context, glo: gl.GLuint): # -> None:
        """
        Destroy the texture.
        This is called automatically when the object is garbage collected.

        :param ctx: OpenGL Context
        :param glo: The OpenGL texture id
        """
        ...
    
    def use(self, unit: int = ...) -> None:
        """Bind the texture to a channel,

        :param unit: The texture unit to bind the texture.
        """
        ...
    
    def bind_to_image(self, unit: int, read: bool = ..., write: bool = ..., level: int = ...): # -> None:
        """
        Bind textures to image units.

        Note that either or both ``read`` and ``write`` needs to be ``True``.
        The supported modes are: read only, write only, read-write

        :param unit: The image unit
        :param read: The compute shader intends to read from this image
        :param write: The compute shader intends to write to this image
        :param level:
        """
        ...
    
    def get_handle(self, resident: bool = ...) -> int:
        """
        Get a handle for bindless texture access.

        Once a handle is created its parameters cannot be changed.
        Attempting to do so will have no effect. (filter, wrap etc).
        There is no way to undo this immutability.

        Handles cannot be used by shaders until they are resident.
        This method can be called multiple times to move a texture
        in and out of residency::

            >> texture.get_handle(resident=False)
            4294969856
            >> texture.get_handle(resident=True)
            4294969856

        Ths same handle is returned if the handle already exists.

        .. note:: Limitations from the OpenGL wiki

            The amount of storage available for resident images/textures may be less
            than the total storage for textures that is available. As such, you should
            attempt to minimize the time a texture spends being resident. Do not attempt
            to take steps like making textures resident/unresident every frame or something.
            But if you are finished using a texture for some time, make it unresident.

        Keyword Args:
            resident (bool): Make the texture resident.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


