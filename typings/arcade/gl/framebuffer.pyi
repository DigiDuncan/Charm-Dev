"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from typing import Generator, List, Optional, TYPE_CHECKING, Tuple
from pyglet import gl
from arcade.types import RGBOrA255, RGBOrANormalized
from .texture import Texture2D
from arcade.gl import Context

if TYPE_CHECKING:
    ...
class Framebuffer:
    """
    An offscreen render target also called a Framebuffer Object in OpenGL.
    This implementation is using texture attachments. When creating a
    Framebuffer we supply it with textures we want our scene rendered into.
    The advantage of using texture attachments is the ability we get
    to keep working on the contents of the framebuffer.

    The best way to create framebuffer is through :py:meth:`arcade.gl.Context.framebuffer`::

        # Create a 100 x 100 framebuffer with one attachment
        ctx.framebuffer(color_attachments=[ctx.texture((100, 100), components=4)])

        # Create a 100 x 100 framebuffer with two attachments
        # Shaders can be configured writing to the different layers
        ctx.framebuffer(
            color_attachments=[
                ctx.texture((100, 100), components=4),
                ctx.texture((100, 100), components=4),
            ]
        )

    :param ctx: The context this framebuffer belongs to
    :param color_attachments: List of color attachments.
    :param depth_attachment: A depth attachment (optional)
    """
    is_default = ...
    __slots__ = ...
    def __init__(self, ctx: Context, *, color_attachments=..., depth_attachment: Optional[Texture2D] = ...) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    @property
    def glo(self) -> gl.GLuint:
        """
        The OpenGL id/name of the framebuffer

        :type: GLuint
        """
        ...
    
    viewport = ...
    scissor = ...
    @property
    def ctx(self) -> Context:
        """
        The context this object belongs to.

        :type: :py:class:`arcade.gl.Context`
        """
        ...
    
    @property
    def width(self) -> int:
        """
        The width of the framebuffer in pixels

        :type: int
        """
        ...
    
    @property
    def height(self) -> int:
        """
        The height of the framebuffer in pixels

        :type: int
        """
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        Size as a ``(w, h)`` tuple

        :type: tuple (int, int)
        """
        ...
    
    @property
    def samples(self) -> int:
        """
        Number of samples (MSAA)

        :type: int
        """
        ...
    
    @property
    def color_attachments(self) -> List[Texture2D]:
        """
        A list of color attachments

        :type: list of :py:class:`arcade.gl.Texture`
        """
        ...
    
    @property
    def depth_attachment(self) -> Optional[Texture2D]:
        """
        Depth attachment

        :type: :py:class:`arcade.gl.Texture`
        """
        ...
    
    @property
    def depth_mask(self) -> bool:
        """
        Get or set the depth mask (default: ``True``).
        It determines if depth values should be written
        to the depth texture when depth testing is enabled.

        The depth mask value is persistent all will automatically
        be applies every time the framebuffer is bound.

        :type: bool
        """
        ...
    
    @depth_mask.setter
    def depth_mask(self, value: bool): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
        ...
    
    @contextmanager
    def activate(self) -> Generator[Framebuffer, None, None]:
        """Context manager for binding the framebuffer.

        Unlike the default context manager in this class
        this support nested framebuffer binding.
        """
        ...
    
    def use(self, *, force: bool = ...): # -> None:
        """Bind the framebuffer making it the target of all rendering commands

        :param force: Force the framebuffer binding even if the system
                           already believes it's already bound.
        """
        ...
    
    def clear(self, *, color: Optional[RGBOrA255] = ..., color_normalized: Optional[RGBOrANormalized] = ..., depth: float = ..., viewport: Optional[Tuple[int, int, int, int]] = ...): # -> None:
        """
        Clears the framebuffer::

            # Clear the framebuffer using arcade's colors (not normalized)
            fb.clear(color=arcade.color.WHITE)

            # Clear framebuffer using the color red in normalized form
            fbo.clear(color_normalized=(1.0, 0.0, 0.0, 1.0))

        If the background color is an ``RGB`` value instead of ``RGBA```
        we assume alpha value 255.

        :param color: A 3 or 4 component tuple containing the color (prioritized over color_normalized)
        :param color_normalized: A 3 or 4 component tuple containing the color in normalized form
        :param depth: Value to clear the depth buffer (unused)
        :param normalized: If the color values are normalized or not
        :param Tuple[int, int, int, int] viewport: The viewport range to clear
        """
        ...
    
    def read(self, *, viewport=..., components=..., attachment=..., dtype=...) -> bytes:
        """
        Read framebuffer pixels

        :param viewport: The x, y, with, height to read
        :param components:
        :param attachment: The attachment id to read from
        :param dtype: The data type to read
        :return: pixel data as a bytearray
        """
        ...
    
    def resize(self): # -> None:
        """
        Detects size changes in attachments.
        This will reset the viewport to ``0, 0, width, height``.
        """
        ...
    
    def delete(self): # -> None:
        """
        Destroy the underlying OpenGL resource.
        Don't use this unless you know exactly what you are doing.
        """
        ...
    
    @staticmethod
    def delete_glo(ctx, framebuffer_id): # -> None:
        """
        Destroys the framebuffer object

        :param ctx: OpenGL context
        :param framebuffer_id: Framebuffer to destroy (glo)
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class DefaultFrameBuffer(Framebuffer):
    """
    Represents the default framebuffer.
    This is the framebuffer of the window itself and need
    some special handling.

    We are not allowed to destroy this framebuffer since
    it's owned by pyglet. This framebuffer can also change
    size and pixel ratio at any point.

    We're doing some initial introspection to guess
    somewhat sane initial values. Since this is a
    dynamic framebuffer we cannot trust the internal
    values. We can only trust what the pyglet window
    itself reports related to window size and
    framebuffer size. This should be updated in the
    ``on_resize`` callback.
    """
    is_default = ...
    __slots__ = ...
    def __init__(self, ctx: Context) -> None:
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        Size as a ``(w, h)`` tuple

        :type: tuple (int, int)
        """
        ...
    
    @property
    def width(self) -> int:
        """
        The width of the framebuffer in pixels

        :type: int
        """
        ...
    
    @property
    def height(self) -> int:
        """
        The height of the framebuffer in pixels

        :type: int
        """
        ...
    
    viewport = ...
    scissor = ...


