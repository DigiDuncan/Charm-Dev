"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, Sequence, TYPE_CHECKING, Union
from pyglet import gl
from .buffer import Buffer
from .types import BufferDescription, GLenumLike, GLuintLike
from .program import Program
from arcade.gl import Context

if TYPE_CHECKING:
    ...
index_types = ...
class VertexArray:
    """
    Wrapper for Vertex Array Objects (VAOs).

    This objects should not be instantiated from user code.
    Use :py:class:`arcade.gl.Geometry` instead. It will create VAO instances for you
    automatically. There is a lot of complex interaction between programs
    and vertex arrays that will be done for you automatically.
    """
    __slots__ = ...
    def __init__(self, ctx: Context, program: Program, content: Sequence[BufferDescription], index_buffer: Optional[Buffer] = ..., index_element_size: int = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __del__(self): # -> None:
        ...
    
    @property
    def ctx(self) -> Context:
        """
        The Context this object belongs to

        :type: :py:class:`arcade.gl.Context`
        """
        ...
    
    @property
    def program(self) -> Program:
        """
        The assigned program

        :type: :py:class:`arcade.gl.Program`
        """
        ...
    
    @property
    def ibo(self) -> Optional[Buffer]:
        """
        Element/index buffer

        :type: :py:class:`arcade.gl.Buffer`
        """
        ...
    
    @property
    def num_vertices(self) -> int:
        """
        The number of vertices

        :type: int
        """
        ...
    
    def delete(self): # -> None:
        """
        Destroy the underlying OpenGL resource.
        Don't use this unless you know exactly what you are doing.
        """
        ...
    
    @staticmethod
    def delete_glo(ctx: Context, glo: gl.GLuint): # -> None:
        """
        Delete this object.
        This is automatically called when this object is garbage collected.
        """
        ...
    
    def render(self, mode: GLenumLike, first: int = ..., vertices: int = ..., instances: int = ...): # -> None:
        """Render the VertexArray to the currently active framebuffer.

        :param mode: Primitive type to render. TRIANGLES, LINES etc.
        :param first: The first vertex to render from
        :param vertices: Number of vertices to render
        :param instances: OpenGL instance, used in using vertices over and over
        """
        ...
    
    def render_indirect(self, buffer: Buffer, mode: GLuintLike, count, first, stride): # -> None:
        """
        Render the VertexArray to the framebuffer using indirect rendering.

        .. Warning:: This requires OpenGL 4.3

        :param buffer: The buffer containing one or multiple draw parameters
        :param mode: Primitive type to render. TRIANGLES, LINES etc.
        :param count: The number if indirect draw calls to run
        :param first: The first indirect draw call to start on
        :param stride: The byte stride of the draw command buffer.
                           Keep the default (0) if the buffer is tightly packed.
        """
        ...
    
    def transform_interleaved(self, buffer: Buffer, mode: GLenumLike, output_mode: GLenumLike, first: int = ..., vertices: int = ..., instances: int = ..., buffer_offset=...): # -> None:
        """Run a transform feedback.

        :param buffer: The buffer to write the output
        :param mode: The input primitive mode
        :param output_mode: The output primitive mode
        :param first: Offset start vertex
        :param vertices: Number of vertices to render
        :param instances: Number of instances to render
        :param buffer_offset: Byte offset for the buffer (target)
        """
        ...
    
    def transform_separate(self, buffers: List[Buffer], mode: GLenumLike, output_mode: GLenumLike, first: int = ..., vertices: int = ..., instances: int = ..., buffer_offset=...): # -> None:
        """
        Run a transform feedback writing to separate buffers.

        :param buffers: The buffers to write the output
        :param mode: The input primitive mode
        :param output_mode: The output primitive mode
        :param first: Offset start vertex
        :param vertices: Number of vertices to render
        :param instances: Number of instances to render
        :param buffer_offset: Byte offset for the buffer (target)
        """
        ...
    


class Geometry:
    """A higher level abstraction of the VertexArray.
    It generates VertexArray instances on the fly internally matching the incoming program.
    This means we can render the same geometry with different programs as long as the
    :py:class:`~arcade.gl.Program` and :py:class:`~arcade.gl.BufferDescription` have compatible attributes.

    Geometry objects should be created through :py:meth:`arcade.gl.Context.geometry`

    :param ctx: The context this object belongs to
    :param content: List of BufferDescriptions
    :param index_buffer: Index/element buffer
    :param mode: The default draw mode
    """
    __slots__ = ...
    def __init__(self, ctx: Context, content: Optional[Sequence[BufferDescription]], index_buffer: Optional[Buffer] = ..., mode: Optional[int] = ..., index_element_size: int = ...) -> None:
        ...
    
    @property
    def ctx(self) -> Context:
        """
        The context this geometry belongs to.

        :type: :py:class:`~arcade.gl.Geometry`
        """
        ...
    
    @property
    def index_buffer(self) -> Optional[Buffer]:
        """
        Index/element buffer if supplied at creation.

        :type: :py:class:`~arcade.gl.Buffer`
        """
        ...
    
    @property
    def num_vertices(self) -> int:
        """
        Get or set the number of vertices.
        Be careful when modifying this properly
        and be absolutely sure what you are doing.

        :type: int
        """
        ...
    
    @num_vertices.setter
    def num_vertices(self, value: int): # -> None:
        ...
    
    def append_buffer_description(self, descr: BufferDescription): # -> None:
        """
        Append a new BufferDescription to the existing Geometry.
        .. Warning:: a Geometry cannot contain two BufferDescriptions which share an attribute name.
        """
        ...
    
    def instance(self, program: Program) -> VertexArray:
        """
        Get the :py:class:`arcade.gl.VertexArray` compatible with this program
        """
        ...
    
    def render(self, program: Program, *, mode: Optional[GLenumLike] = ..., first: int = ..., vertices: Optional[int] = ..., instances: int = ...) -> None:
        """Render the geometry with a specific program.

        The geometry object will know how many vertices your buffers contains
        so overriding vertices is not needed unless you have a special case
        or have resized the buffers after the geometry instance was created.

        :param program: The Program to render with
        :param mode: Override what primitive mode should be used
        :param first: Offset start vertex
        :param vertices: Override the number of vertices to render
        :param instances: Number of instances to render
        """
        ...
    
    def render_indirect(self, program: Program, buffer: Buffer, *, mode: Optional[GLuintLike] = ..., count: int = ..., first: int = ..., stride: int = ...): # -> None:
        """
        Render the VertexArray to the framebuffer using indirect rendering.

        .. Warning:: This requires OpenGL 4.3

        The following structs are expected for the buffer::

            // Array rendering - no index buffer (16 bytes)
            typedef  struct {
                uint  count;
                uint  instanceCount;
                uint  first;
                uint  baseInstance;
            } DrawArraysIndirectCommand;

            // Index rendering - with index buffer 20 bytes
            typedef  struct {
                GLuint  count;
                GLuint  instanceCount;
                GLuint  firstIndex;
                GLuint  baseVertex;
                GLuint  baseInstance;
            } DrawElementsIndirectCommand;

        The ``stride`` is the byte stride between every redering command
        in the buffer. By default we assume this is 16 for array rendering
        (no index buffer) and 20 for indexed rendering (with index buffer)

        :param program: The program to execute
        :param buffer: The buffer containing one or multiple draw parameters
        :param mode: Primitive type to render. TRIANGLES, LINES etc.
        :param count: The number if indirect draw calls to run.
                          If omitted all draw commands in the buffer will be executed.
        :param first: The first indirect draw call to start on
        :param stride: The byte stride of the draw command buffer.
                           Keep the default (0) if the buffer is tightly packed.
        """
        ...
    
    def transform(self, program: Program, buffer: Union[Buffer, List[Buffer]], *, first: int = ..., vertices: Optional[int] = ..., instances: int = ..., buffer_offset: int = ...) -> None:
        """Render with transform feedback. Instead of rendering to the screen
        or a framebuffer the result will instead end up in the ``buffer`` we supply.

        If a geometry shader is used the output primitive mode is automatically detected.

        :param program: The Program to render with
        :param Union[Buffer, Sequence[Buffer]] buffer: The buffer(s) we transform into.
            This depends on the programs ``varyings_capture_mode``. We can transform
            into one buffer interlaved or transform each attribute into separate buffers.
        :param first: Offset start vertex
        :param vertices: Number of vertices to render
        :param instances: Number of instances to render
        :param buffer_offset: Byte offset for the buffer
        """
        ...
    
    def flush(self) -> None:
        """
        Flush all the internally generated VertexArrays.

        The Geometry instance will store a VertexArray
        for every unique set of input attributes it
        stumbles over when redering and transform calls
        are issued. This data is usually pretty light weight
        and usually don't need flushing.
        """
        ...
    


