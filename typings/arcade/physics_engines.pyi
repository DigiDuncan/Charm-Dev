"""
This type stub file was generated by pyright.
"""

from typing import Iterable, Optional, Union
from arcade import Sprite, SpriteList
from arcade.utils import copy_dunders_unimplemented

"""
Physics engines for top-down or platformers.
"""
__all__ = ["PhysicsEngineSimple", "PhysicsEnginePlatformer"]
@copy_dunders_unimplemented
class PhysicsEngineSimple:
    """
    Simplistic physics engine for use in games without gravity, such as top-down
    games. It is easier to get
    started with this engine than more sophisticated engines like PyMunk.

    :param player_sprite: The moving sprite
    :param  Union[SpriteList, Iterable[SpriteList] walls: The sprites it can't move through.
        This can be one or multiple spritelists.
    """
    def __init__(self, player_sprite: Sprite, walls: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...) -> None:
        ...
    
    @property
    def walls(self): # -> List[SpriteList[Any]]:
        ...
    
    @walls.setter
    def walls(self, walls: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...): # -> None:
        ...
    
    @walls.deleter
    def walls(self): # -> None:
        ...
    
    def update(self): # -> List[Any]:
        """
        Move everything and resolve collisions.

        :Returns: SpriteList with all sprites contacted. Empty list if no sprites.
        """
        ...
    


@copy_dunders_unimplemented
class PhysicsEnginePlatformer:
    """
    Simplistic physics engine for use in a platformer. It is easier to get
    started with this engine than more sophisticated engines like PyMunk.

    **Note:** Sending static sprites to the ``walls`` parameter and moving sprites to the
    ``platforms`` parameter will have very extreme benefits to performance.

    **Note:** This engine will automatically move any Sprites sent to the ``platforms``
    parameter between a ``boundary_top`` and ``boundary_bottom`` or a ``boundary_left``
    and ``boundary_right`` attribute of the Sprite. You need only set an initial
    ``change_x`` or ``change_y`` on it.

    :param player_sprite: The moving sprite
    :param Optional[Union[SpriteList, Iterable[SpriteList]]] platforms: Sprites the player can't move through.
        This value should only be used for moving Sprites. Static sprites should be sent to the ``walls`` parameter.
    :param gravity_constant: Downward acceleration per frame
    :param Optional[Union[SpriteList, Iterable[SpriteList]]] ladders: Ladders the user can climb on
    :param Optional[Union[SpriteList, Iterable[SpriteList]]] walls: Sprites the player can't move through.
        This value should only be used for static Sprites. Moving sprites should be sent to the ``platforms`` parameter.
    """
    def __init__(self, player_sprite: Sprite, platforms: Optional[Union[SpriteList, Iterable[SpriteList]]] = ..., gravity_constant: float = ..., ladders: Optional[Union[SpriteList, Iterable[SpriteList]]] = ..., walls: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...) -> None:
        ...
    
    @property
    def ladders(self): # -> List[SpriteList[Any]] | None:
        """ The ladder list registered with the physics engine."""
        ...
    
    @ladders.setter
    def ladders(self, ladders: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...): # -> None:
        ...
    
    @ladders.deleter
    def ladders(self): # -> None:
        ...
    
    @property
    def platforms(self): # -> List[SpriteList[Any]]:
        """ The moving platform list registered with the physics engine."""
        ...
    
    @platforms.setter
    def platforms(self, platforms: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...): # -> None:
        ...
    
    @platforms.deleter
    def platforms(self): # -> None:
        ...
    
    @property
    def walls(self): # -> List[SpriteList[Any]]:
        """ The wall list registered with the physics engine."""
        ...
    
    @walls.setter
    def walls(self, walls: Optional[Union[SpriteList, Iterable[SpriteList]]] = ...): # -> None:
        ...
    
    @walls.deleter
    def walls(self): # -> None:
        ...
    
    def is_on_ladder(self): # -> bool:
        """ Return 'true' if the player is in contact with a sprite in the ladder list. """
        ...
    
    def can_jump(self, y_distance: float = ...) -> bool:
        """
        Method that looks to see if there is a floor under
        the player_sprite. If there is a floor, the player can jump
        and we return a True.

        :returns: True if there is a platform below us
        """
        ...
    
    def enable_multi_jump(self, allowed_jumps: int): # -> None:
        """
        Enables multi-jump.
        allowed_jumps should include the initial jump.
        (1 allows only a single jump, 2 enables double-jump, etc)

        If you enable multi-jump, you MUST call increment_jump_counter()
        every time the player jumps. Otherwise they can jump infinitely.

        :param allowed_jumps:
        """
        ...
    
    def disable_multi_jump(self): # -> None:
        """
        Disables multi-jump.

        Calling this function also removes the requirement to
        call increment_jump_counter() every time the player jumps.
        """
        ...
    
    def jump(self, velocity: int): # -> None:
        """ Have the character jump. """
        ...
    
    def increment_jump_counter(self): # -> None:
        """
        Updates the jump counter for multi-jump tracking
        """
        ...
    
    def update(self): # -> List[Any]:
        """
        Move everything and resolve collisions.

        :Returns: SpriteList with all sprites contacted. Empty list if no sprites.
        """
        ...
    


