"""
This type stub file was generated by pyright.
"""

import pymunk
from typing import Callable, Optional, Tuple, Union
from pyglet.math import Vec2
from arcade import Sprite
from arcade.utils import copy_dunders_unimplemented

"""
Pymunk Physics Engine
"""
__all__ = ["PymunkPhysicsObject", "PymunkException", "PymunkPhysicsEngine"]
LOG = ...
class PymunkPhysicsObject:
    """ Object that holds pymunk body/shape for a sprite. """
    def __init__(self, body: Optional[pymunk.Body] = ..., shape: Optional[pymunk.Shape] = ...) -> None:
        ...
    


class PymunkException(Exception):
    """Exception raised for errors in the PymunkPhysicsEngine."""
    ...


@copy_dunders_unimplemented
class PymunkPhysicsEngine:
    """
    Pymunk Physics Engine

    :param gravity: The direction where gravity is pointing
    :param damping: The amount of speed which is kept to the next tick. A value of 1.0 means no speed loss,
                    while 0.9 has 10% loss of speed etc.
    :param maximum_incline_on_ground: The maximum incline the ground can have, before is_on_ground() becomes False
        default = 0.708 or a little bit over 45Â° angle
    """
    DYNAMIC = ...
    STATIC = ...
    KINEMATIC = ...
    MOMENT_INF = ...
    def __init__(self, gravity=..., damping: float = ..., maximum_incline_on_ground: float = ...) -> None:
        ...
    
    def add_sprite(self, sprite: Sprite, mass: float = ..., friction: float = ..., elasticity: Optional[float] = ..., moment_of_inertia: Optional[float] = ..., body_type: int = ..., damping: Optional[float] = ..., gravity: Optional[Union[pymunk.Vec2d, Tuple[float, float], Vec2]] = ..., max_velocity: Optional[int] = ..., max_horizontal_velocity: Optional[int] = ..., max_vertical_velocity: Optional[int] = ..., radius: float = ..., collision_type: Optional[str] = ...): # -> None:
        """ Add a sprite to the physics engine.

            :param sprite: The sprite to add.
            :param mass: The mass of the object. Defaults to 1.
            :param friction: The friction the object has. Defaults to 0.2.
            :param elasticity: How bouncy this object is. 0 is no bounce. Values of 1.0 and higher may behave badly.
            :param moment_of_inertia: The moment of inertia, or force needed to change angular momentum. \
            Providing infinite makes this object stuck in its rotation.
            :param body_type: The type of the body. Defaults to Dynamic, meaning, the body can move, rotate etc. \
            Providing STATIC makes it fixed to the world.
            :param damping: See class docs.
            :param gravity: See class docs.
            :param max_velocity: The maximum velocity of the object.
            :param max_horizontal_velocity: Maximum velocity on the x axis in pixels.
            :param max_vertical_velocity: Maximum velocity on the y axis in pixels.
            :param radius: Radius for the shape created for the sprite in pixels.
            :param collision_type: Assign a name to the sprite, use this name when adding collision handler.
        """
        ...
    
    def add_sprite_list(self, sprite_list, mass: float = ..., friction: float = ..., elasticity: Optional[float] = ..., moment_of_inertia: Optional[float] = ..., body_type: int = ..., damping: Optional[float] = ..., collision_type: Optional[str] = ...): # -> None:
        """ Add all sprites in a sprite list to the physics engine. """
        ...
    
    def remove_sprite(self, sprite: Sprite): # -> None:
        """ Remove a sprite from the physics engine. """
        ...
    
    def get_sprite_for_shape(self, shape: Optional[pymunk.Shape]) -> Optional[Sprite]:
        """ Given a shape, what sprite is associated with it? """
        ...
    
    def get_sprites_from_arbiter(self, arbiter: pymunk.Arbiter) -> Tuple[Optional[Sprite], Optional[Sprite]]:
        """ Given a collision arbiter, return the sprites associated with the collision. """
        ...
    
    def is_on_ground(self, sprite: Sprite) -> bool:
        """ Return true of sprite is on top of something. """
        ...
    
    def apply_impulse(self, sprite: Sprite, impulse: Tuple[float, float]): # -> None:
        """ Apply an impulse force on a sprite """
        ...
    
    def set_position(self, sprite: Sprite, position: Union[pymunk.Vec2d, Tuple[float, float]]): # -> None:
        """ Apply an impulse force on a sprite """
        ...
    
    def set_rotation(self, sprite: Sprite, rotation: float): # -> None:
        ...
    
    def set_velocity(self, sprite: Sprite, velocity: Tuple[float, float]): # -> None:
        """ Apply an impulse force on a sprite """
        ...
    
    def add_collision_handler(self, first_type: str, second_type: str, begin_handler: Optional[Callable] = ..., pre_handler: Optional[Callable] = ..., post_handler: Optional[Callable] = ..., separate_handler: Optional[Callable] = ...): # -> None:
        """ Add code to handle collisions between objects. """
        ...
    
    def resync_sprites(self): # -> None:
        """
        Set visual sprites to be the same location as physics engine sprites.
        Call this after stepping the pymunk physics engine
        """
        ...
    
    def step(self, delta_time: float = ..., resync_sprites: bool = ...): # -> None:
        """
        Tell the physics engine to perform calculations.

        :param delta_time: Time to move the simulation forward. Keep this
                                 value constant, do not use varying values for
                                 each step.
        :param resync_sprites: Resynchronize Arcade graphical sprites to be
                                    at the same location as their Pymunk counterparts.
                                    If running multiple steps per frame, set this to
                                    false for the first steps, and true for the last
                                    step that's part of the update.
        """
        ...
    
    def get_physics_object(self, sprite: Sprite) -> PymunkPhysicsObject:
        """ Get the shape/body for a sprite. """
        ...
    
    def apply_force(self, sprite: Sprite, force: Tuple[float, float]): # -> None:
        """ Apply force to a Sprite. """
        ...
    
    def set_horizontal_velocity(self, sprite: Sprite, velocity: float): # -> None:
        """ Set a sprite's velocity """
        ...
    
    def set_friction(self, sprite: Sprite, friction: float): # -> None:
        """ Apply force to a Sprite. """
        ...
    
    def apply_opposite_running_force(self, sprite: Sprite): # -> None:
        """
        If a sprite goes left while on top of a dynamic sprite, that sprite
        should get pushed to the right.
        """
        ...
    
    def check_grounding(self, sprite: Sprite): # -> dict[str, Any]:
        """ See if the player is on the ground. Used to see if we can jump. """
        ...
    


