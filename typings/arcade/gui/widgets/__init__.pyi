"""
This type stub file was generated by pyright.
"""

import arcade
from __future__ import annotations
from abc import ABC
from math import floor
from random import randint
from typing import Callable, Dict, Iterable, List, NamedTuple, Optional, TYPE_CHECKING, Tuple, TypeVar, Union
from pyglet.event import EVENT_HANDLED, EVENT_UNHANDLED, EventDispatcher
from typing_extensions import Self
from arcade import Sprite, Texture
from arcade.color import TRANSPARENT_BLACK
from arcade.gui.events import UIEvent, UIMouseMovementEvent, UIMousePressEvent, UIMouseReleaseEvent, UIOnClickEvent, UIOnUpdateEvent
from arcade.gui.nine_patch import NinePatchTexture
from arcade.gui.property import ListProperty, Property, bind
from arcade.gui.surface import Surface
from arcade.types import AsFloat, Color, Point, RGBA255
from arcade.utils import copy_dunders_unimplemented
from arcade.gui.ui_manager import UIManager

if TYPE_CHECKING:
    ...
__all__ = ["Surface", "UIDummy"]
class GUIRect(NamedTuple):
    """
    Representing a rectangle for GUI module.
    Rect is idempotent.

    Bottom left corner is used as fix point (x, y)
    """
    x: float
    y: float
    width: float
    height: float
    def move(self, dx: AsFloat = ..., dy: AsFloat = ...) -> GUIRect:
        """Returns new Rect which is moved by dx and dy"""
        ...
    
    def collide_with_point(self, x: AsFloat, y: AsFloat) -> bool:
        """Return true if ``x`` and ``y`` are within this rect.

        This check is inclusive. Values on the :py:attr:`.left`,
        :py:attr:`.right`, :py:attr:`.top`, and :py:attr:`.bottom`
        edges will be counted as inside the rect.

        .. code-block:: python

           >>> bounds = Rect(0.0, 0.0, 5.0, 5.0)
           >>> bounds.collide_with_point(0.0, 0.0)
           True
           >>> bounds.collide_with_point(5.0, 5.0)
           True

        :param x: The x value to check as inside the rect.
        :param y: The y value to check as inside the rect.
        """
        ...
    
    def scale(self, scale: float, rounding: Optional[Callable[..., float]] = ...) -> GUIRect:
        """Return a new rect scaled relative to the origin.

        By default, the new rect's values are rounded down to whole
        values. You can alter this by passing a different rounding
        behavior:

        * Pass ``None`` to skip rounding
        * Pass a function which takes a number and returns a float
          to choose rounding behavior.

        :param scale: A scale factor.
        :param rounding: ``None`` or a callable specifying how to
            round the scaled values.
        """
        ...
    
    def resize(self, width: float | None = ..., height: float | None = ...) -> GUIRect:
        """Return a rect with a new width or height but same lower left.

        Fix x and y coordinate.
        :param width: A width for the new rectangle.
        :param height: A height for the new rectangle.
        """
        ...
    
    @property
    def size(self) -> Tuple[float, float]:
        """Read-only pixel size of the rect.

        Since these rects are immutable, use helper instance methods to
        get updated rects. For example, :py:meth:`.resize` may be what
        you're looking for.
        """
        ...
    
    @property
    def left(self) -> float:
        """The left edge on the X axis."""
        ...
    
    @property
    def right(self) -> float:
        """The right edge on the X axis."""
        ...
    
    @property
    def bottom(self) -> float:
        """The bottom edge on the Y axis."""
        ...
    
    @property
    def top(self) -> float:
        """The top edge on the Y axis."""
        ...
    
    @property
    def center_x(self) -> float:
        ...
    
    @property
    def center_y(self) -> float:
        ...
    
    @property
    def center(self) -> Point:
        ...
    
    @property
    def position(self) -> Point:
        """Bottom left coordinates"""
        ...
    
    def align_top(self, value: float) -> GUIRect:
        """Returns new Rect, which is aligned to the top"""
        ...
    
    def align_bottom(self, value: float) -> GUIRect:
        """Returns new Rect, which is aligned to the bottom"""
        ...
    
    def align_left(self, value: float) -> GUIRect:
        """Returns new Rect, which is aligned to the left"""
        ...
    
    def align_right(self, value: AsFloat) -> GUIRect:
        """Returns new Rect, which is aligned to the right"""
        ...
    
    def align_center(self, center_x: AsFloat, center_y: AsFloat) -> GUIRect:
        """Returns new Rect, which is aligned to the center x and y"""
        ...
    
    def align_center_x(self, value: AsFloat) -> GUIRect:
        """Returns new Rect, which is aligned to the center_x"""
        ...
    
    def align_center_y(self, value: AsFloat) -> GUIRect:
        """Returns new Rect, which is aligned to the center_y"""
        ...
    
    def min_size(self, width: Optional[AsFloat] = ..., height: Optional[AsFloat] = ...) -> GUIRect:
        """
        Sets the size to at least the given min values.
        """
        ...
    
    def max_size(self, width: Optional[AsFloat] = ..., height: Optional[AsFloat] = ...) -> GUIRect:
        """
        Limits the size to the given max values.
        """
        ...
    
    def union(self, rect: GUIRect) -> GUIRect:
        """
        Returns a new Rect that is the union of this rect and another.
        The union is the smallest rectangle that contains theses two rectangles.
        """
        ...
    


W = TypeVar("W", bound="UIWidget")
class _ChildEntry(NamedTuple):
    child: UIWidget
    data: Dict
    ...


@copy_dunders_unimplemented
class UIWidget(EventDispatcher, ABC):
    """
    The :class:`UIWidget` class is the base class required for creating widgets.

    We also have some default values and behaviors that you should be aware of:

    * A :class:`UIWidget` is not a :class:`~arcade.gui.UILayout`: it will not
      change the position or the size of its children. If you want control over
      positioning or sizing, use a :class:`~arcade.gui.UILayout`.

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param width: width of widget
    :param height: height of widget
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel
    :param style: not used
    """
    rect: GUIRect = ...
    visible: bool = ...
    size_hint: Optional[Tuple[float, float]] = ...
    size_hint_min: Optional[Tuple[float, float]] = ...
    size_hint_max: Optional[Tuple[float, float]] = ...
    _children: List[_ChildEntry] = ...
    _border_width: int = ...
    _border_color: Optional[RGBA255] = ...
    _bg_color: Optional[RGBA255] = ...
    _bg_tex: Union[None, Texture, NinePatchTexture] = ...
    _padding_top: int = ...
    _padding_right: int = ...
    _padding_bottom: int = ...
    _padding_left: int = ...
    def __init__(self, *, x: float = ..., y: float = ..., width: float = ..., height: float = ..., children: Iterable[UIWidget] = ..., size_hint=..., size_hint_min=..., size_hint_max=..., **kwargs) -> None:
        ...
    
    def add(self, child: W, **kwargs) -> W:
        """
        Add a widget to this :class:`UIWidget` as a child.
        Added widgets will receive ui events and be rendered.

        By default, the latest added widget will receive ui events first and will be rendered on top of others.

        :param child: widget to add
        :param index: position a widget is added, None has the highest priority
        :return: given child
        """
        ...
    
    def remove(self, child: UIWidget): # -> None:
        """
        Removes a child from the UIManager which was directly added to it.
        This will not remove widgets which are added to a child of UIManager.
        """
        ...
    
    def clear(self): # -> None:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def on_update(self, dt): # -> None:
        """Custom logic which will be triggered."""
        ...
    
    def on_event(self, event: UIEvent) -> Optional[bool]:
        """Passes :class:`UIEvent` s through the widget tree."""
        ...
    
    def trigger_render(self): # -> None:
        """
        This will delay a render right before the next frame is rendered, so that :meth:`UIWidget.do_render`
        is not called multiple times.
        """
        ...
    
    def trigger_full_render(self) -> None:
        """In case a widget uses transparent areas or was moved,
        it might be important to request a full rendering of parents"""
        ...
    
    def do_render_base(self, surface: Surface): # -> None:
        """
        Renders background, border and "padding"
        """
        ...
    
    def prepare_render(self, surface): # -> None:
        """
        Helper for rendering, the drawing area will be adjusted to the own position and size.
        Draw calls have to be relative to 0,0.
        This will also prevent any overdraw outside of the widgets area

        :param surface: Surface used for rendering
        """
        ...
    
    def do_render(self, surface: Surface): # -> None:
        """Render the widgets graphical representation, use :meth:`UIWidget.prepare_render` to limit the drawing area
        to the widgets rect and draw relative to 0,0."""
        ...
    
    def dispatch_ui_event(self, event: UIEvent):
        """Dispatch a :class:`UIEvent` using pyglet event dispatch mechanism"""
        ...
    
    def move(self, dx=..., dy=...): # -> None:
        """
        Move the widget by dx and dy.

        :param dx: x axis difference
        :param dy: y axis difference
        """
        ...
    
    def scale(self, factor): # -> None:
        """
        Scales the size of the widget (x,y,width, height) by factor.
        :param factor: scale factor
        """
        ...
    
    @property
    def x(self): # -> float:
        ...
    
    @property
    def left(self): # -> float:
        ...
    
    @property
    def right(self): # -> float:
        ...
    
    @property
    def y(self): # -> float:
        ...
    
    @property
    def bottom(self): # -> float:
        ...
    
    @property
    def top(self): # -> float:
        ...
    
    @property
    def position(self): # -> tuple[float, float]:
        """Returns bottom left coordinates"""
        ...
    
    @property
    def center(self): # -> Point:
        ...
    
    @center.setter
    def center(self, value: Tuple[int, int]): # -> None:
        ...
    
    @property
    def center_x(self): # -> float:
        ...
    
    @property
    def center_y(self): # -> float:
        ...
    
    @property
    def padding(self): # -> tuple[int, int, int, int]:
        ...
    
    @padding.setter
    def padding(self, args: Union[int, Tuple[int, int], Tuple[int, int, int, int]]): # -> None:
        ...
    
    @property
    def children(self) -> List[UIWidget]:
        ...
    
    def __iter__(self): # -> Iterator[UIWidget]:
        ...
    
    def resize(self, *, width=..., height=...): # -> None:
        ...
    
    def with_border(self, *, width=..., color=...) -> Self:
        """
        Sets border properties
        :param width: border width
        :param color: border color
        :return: self
        """
        ...
    
    def with_padding(self, *, top: Optional[int] = ..., right: Optional[int] = ..., bottom: Optional[int] = ..., left: Optional[int] = ..., all: Optional[int] = ...) -> UIWidget:
        """
        Changes the padding to the given values if set. Returns itself
        :return: self
        """
        ...
    
    def with_background(self, *, color: Union[None, Color] = ..., texture: Union[None, Texture, NinePatchTexture] = ...) -> UIWidget:
        """
        Set widgets background.

        A color or texture can be used for background,
        if a texture is given, start and end point can be added to use the texture as ninepatch.

        :param color: A color used as background
        :param texture: A texture or ninepatch texture used as background
        :return: self
        """
        ...
    
    @property
    def content_size(self): # -> tuple[float, float]:
        ...
    
    @property
    def content_width(self): # -> float:
        ...
    
    @property
    def content_height(self): # -> float:
        ...
    
    @property
    def content_rect(self): # -> GUIRect:
        ...
    
    @property
    def width(self): # -> float:
        ...
    
    @property
    def height(self): # -> float:
        ...
    
    @property
    def size(self): # -> tuple[float, float]:
        ...
    
    def center_on_screen(self: W) -> W:
        """
        Places this widget in the center of the current window.
        """
        ...
    


class UIInteractiveWidget(UIWidget):
    """
    Base class for widgets which use mouse interaction (hover, pressed, clicked)

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param width: width of widget
    :param height: height of widget
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel:param x: center x of widget
    :param interaction_buttons: defines, which mouse buttons should trigger the interaction (default: left mouse button)
    :param style: not used
    """
    hovered = ...
    pressed = ...
    disabled = ...
    def __init__(self, *, x: float = ..., y: float = ..., width: float, height: float, size_hint=..., size_hint_min=..., size_hint_max=..., interaction_buttons=..., **kwargs) -> None:
        ...
    
    def on_event(self, event: UIEvent) -> Optional[bool]:
        ...
    
    def on_click(self, event: UIOnClickEvent): # -> None:
        ...
    


class UIDummy(UIInteractiveWidget):
    """
    Solid color widget used for testing & examples

    It should not be subclassed for real-world usage.

    When clicked, it does the following:

    * Outputs its `rect` attribute to the console
    * Changes its color to a random fully opaque color

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param color: fill color for the widget
    :param width: width of widget
    :param height: height of widget
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel
    :param style: not used
    """
    def __init__(self, *, x=..., y=..., width=..., height=..., size_hint=..., size_hint_min=..., size_hint_max=..., **kwargs) -> None:
        ...
    
    def on_click(self, event: UIOnClickEvent): # -> None:
        ...
    
    def on_update(self, dt): # -> None:
        ...
    
    def do_render(self, surface: Surface): # -> None:
        ...
    


class UISpriteWidget(UIWidget):
    """Create a UI element with a sprite that controls what is displayed.

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param width: width of widget
    :param height: height of widget
    :param sprite: Sprite to embed in gui
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel
    :param style: not used
    """
    def __init__(self, *, x=..., y=..., width=..., height=..., sprite: Optional[Sprite] = ..., size_hint=..., size_hint_min=..., size_hint_max=..., **kwargs) -> None:
        ...
    
    def on_update(self, dt): # -> None:
        ...
    
    def do_render(self, surface: Surface): # -> None:
        ...
    


class UILayout(UIWidget):
    """
    Base class for widgets, which position themselves or their children.

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param width: width of widget
    :param height: height of widget
    :param children: Child widgets of this group
    :param size_hint: A hint for :class:`UILayout`, if this :class:`UIWidget` would like to grow
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel
    :param style: not used
    """
    @staticmethod
    def min_size_of(child: UIWidget) -> Tuple[float, float]:
        """
        Resolves the minimum size of a child. If it has a size_hint set for the axis,
        it will use size_hint_min if set, otherwise the size will be used.
        """
        ...
    
    def prepare_layout(self): # -> None:
        """
        Triggered by the UIManager before layouting,
        :class:`UILayout` s should prepare themselves based on children.

        Prepare layout is triggered on children first.
        """
        ...
    
    def do_layout(self): # -> None:
        """
        Triggered by the UIManager before rendering, :class:`UILayout` s should place themselves and/or children.
        Do layout will be triggered on children afterward.

        Use :meth:`UIWidget.trigger_render` to trigger a rendering before the next frame, this will happen automatically
        if the position or size of this widget changed.
        """
        ...
    


class UISpace(UIWidget):
    """
    Widget reserving space, can also have a background color.

    :param x: x coordinate of bottom left
    :param y: y coordinate of bottom left
    :param width: width of widget
    :param height: height of widget
    :param color: Color for widget area
    :param size_hint: Tuple of floats (0.0-1.0), how much space of the parent should be requested
    :param size_hint_min: min width and height in pixel
    :param size_hint_max: max width and height in pixel
    :param style: not used
    """
    def __init__(self, *, x=..., y=..., width=..., height=..., color=..., size_hint=..., size_hint_min=..., size_hint_max=..., **kwargs) -> None:
        ...
    
    @property
    def color(self): # -> Color:
        ...
    
    @color.setter
    def color(self, value): # -> None:
        ...
    
    def do_render(self, surface: Surface): # -> None:
        ...
    


