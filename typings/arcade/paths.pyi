"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, Set, Tuple, Union
from arcade import Sprite, SpriteList
from arcade.types import Point

"""
Classic A-star algorithm for path finding.
"""
__all__ = ["AStarBarrierList", "astar_calculate_path", "has_line_of_sight"]
class _AStarGraph:
    """
    A grid which tracks 2 barriers and a moving sprite.

    :param Union[List, Tuple, Set] barriers: Is turned into a set, and then used for _AStarSearch
    :param left: Far left side x value
    :param right: Far right side x value
    :param bottom: Far bottom side y value
    :param top: Far top side y value
    """
    def __init__(self, barriers: Union[List, Tuple, Set], left: int, right: int, bottom: int, top: int, diagonal_movement: bool) -> None:
        ...
    
    def get_vertex_neighbours(self, pos: Point) -> List[Tuple[float, float]]:
        """
        Return neighbors for this point according to ``self.movement_directions``

        These are not guaranteed to be reachable or valid points.

        :param pos: Which position to search around

        :return: Returns vertexes around the point
        """
        ...
    
    def move_cost(self, a: Point, b: Point) -> float:
        """
        Returns a float of the cost to move

        Moving diagonally costs more than to the side.
        A barrier's cost is float("inf) so that that
        the Algorithm will never go on it

        :param a: The 1st point to compare
        :param b: The 2nd point to compare

        :return: The move cost of moving between of the 2 points
        """
        ...
    


class AStarBarrierList:
    """
    Class that manages a list of barriers that can be encountered during
    A* path finding.

    :param moving_sprite: Sprite that will be moving
    :param blocking_sprites: Sprites that can block movement
    :param grid_size: Size of the grid, in pixels
    :param left: Left border of playing field
    :param right: Right border of playing field
    :param bottom: Bottom of playing field
    :param top: Top of playing field
    :param barrier_list: SpriteList of barriers to use in _AStarSearch, None if not recalculated
    """
    def __init__(self, moving_sprite: Sprite, blocking_sprites: SpriteList, grid_size: int, left: int, right: int, bottom: int, top: int) -> None:
        ...
    
    def recalculate(self): # -> None:
        """
        Recalculate blocking sprites.
        """
        ...
    


def astar_calculate_path(start_point: Point, end_point: Point, astar_barrier_list: AStarBarrierList, diagonal_movement: bool = ...) -> Optional[List[Point]]:
    """
    Calculates the path using AStarSearch Algorithm and returns the path

    :param start_point: Where it starts
    :param end_point: Where it ends
    :param astar_barrier_list: AStarBarrierList with the boundries to use in the AStarSearch Algorithm
    :param diagonal_movement: Whether of not to use diagonals in the AStarSearch Algorithm

    :return: List of points(the path), or None if no path is found
    """
    ...

def has_line_of_sight(observer: Point, target: Point, walls: SpriteList, max_distance: float = ..., check_resolution: int = ...) -> bool:
    """
    Determine if we have line of sight between two points.

    :param observer: Start position
    :param target: End position position
    :param walls: List of all blocking sprites
    :param max_distance: Max distance point 1 can see
    :param check_resolution: Check every x pixels for a sprite. Trade-off between accuracy and speed.

    .. warning:: Try to make sure spatial hashing is enabled on ``walls``!

                 If spatial hashing is not enabled, this function may run
                 very slowly!

    :return: Whether or not oberver to target is blocked by any wall in walls
    """
    ...

