"""
This type stub file was generated by pyright.
"""

from typing import Sequence, Tuple, Union
from arcade.types import AsFloat, Point, Point2

_PRECISION = ...
__all__ = ["round_fast", "clamp", "lerp", "lerp_2d", "lerp_3d", "lerp_angle", "rand_in_rect", "rand_in_circle", "rand_on_circle", "rand_on_line", "rand_angle_360_deg", "rand_angle_spread_deg", "rand_vec_spread_deg", "rand_vec_magnitude", "get_distance", "rotate_point", "get_angle_degrees", "get_angle_radians", "quaternion_rotation"]
def round_fast(value: float, precision: int) -> float:
    """
    A high performance version of python's built-in round() function.

    .. note:: This function is not as accurate as the built-in round() function.
              But is sufficient in some cases.

    Example::

        >>> round(3.5662457892, 1)
        3.6
        >>> round(3.5662457892, 2)
        3.57
        >>> round(3.5662457892, 3)
        3.566
        >>> round(3.5662457892, 4)
        3.5662

    :param value: The value to round
    :param precision: The number of decimal places to round to
    :return: The rounded value
    """
    ...

def clamp(a, low: float, high: float) -> float:
    """ Clamp a number between a range. """
    ...

V_2D = Union[Tuple[AsFloat, AsFloat], Sequence[AsFloat]]
V_3D = Union[Tuple[AsFloat, AsFloat, AsFloat], Sequence[AsFloat]]
def lerp(v1: AsFloat, v2: AsFloat, u: float) -> float:
    """linearly interpolate between two values"""
    ...

def lerp_2d(v1: V_2D, v2: V_2D, u: float) -> Tuple[float, float]:
    ...

def lerp_3d(v1: V_3D, v2: V_3D, u: float) -> Tuple[float, float, float]:
    ...

def lerp_angle(start_angle: float, end_angle: float, u: float) -> float:
    """
    Linearly interpolate between two angles in degrees,
    following the shortest path.

    :param start_angle: The starting angle
    :param end_angle: The ending angle
    :param u: The interpolation value
    :return: The interpolated angle
    """
    ...

def rand_in_rect(bottom_left: Point2, width: float, height: float) -> Point:
    """
    Calculate a random point in a rectangle.

    :param bottom_left: The bottom left corner of the rectangle
    :param width: The width of the rectangle
    :param height: The height of the rectangle
    :return: A random point in the rectangle
    """
    ...

def rand_in_circle(center: Point2, radius: float) -> Point2:
    """
    Generate a point in a circle, or can think of it as a vector pointing
    a random direction with a random magnitude <= radius.

    Reference: https://stackoverflow.com/a/30564123

    .. note:: This algorithm returns a higher concentration of points
              around the center of the circle

    :param center: The center of the circle
    :param radius: The radius of the circle
    :return: A random point in the circle
    """
    ...

def rand_on_circle(center: Point2, radius: float) -> Point2:
    """
    Generate a point on a circle.

    .. note: by passing a random value in for float,
             you can achieve what rand_in_circle() does

    :param center: The center of the circle
    :param radius: The radius of the circle
    :return: A random point on the circle
    """
    ...

def rand_on_line(pos1: Point2, pos2: Point2) -> Point:
    """
    Given two points defining a line, return a random point on that line.

    :param pos1: The first point
    :param pos2: The second point
    :return: A random point on the line
    """
    ...

def rand_angle_360_deg() -> float:
    """
    Returns a random angle in degrees.
    """
    ...

def rand_angle_spread_deg(angle: float, half_angle_spread: float) -> float:
    """
    Returns a random angle in degrees, within a spread of the given angle.

    :param angle: The angle to spread from
    :param half_angle_spread: The half angle spread
    :return: A random angle in degrees
    """
    ...

def rand_vec_spread_deg(angle: float, half_angle_spread: float, length: float) -> tuple[float, float]:
    """
    Returns a random vector, within a spread of the given angle.

    :param angle: The angle to spread from
    :param half_angle_spread: The half angle spread
    :param length: The length of the vector
    :return: A random vector
    """
    ...

def rand_vec_magnitude(angle: float, lo_magnitude: float, hi_magnitude: float) -> tuple[float, float]:
    """
    Returns a random vector, within a spread of the given angle.

    :param angle: The angle to spread from
    :param lo_magnitude: The lower magnitude
    :param hi_magnitude: The higher magnitude
    :return: A random vector
    """
    ...

class _Vec2:
    """
    2D vector used to do operate points and vectors

    Note: intended to be used for internal implementations only.
    Should not be part of public interfaces
    (ex: function parameters or return values).
    """
    __slots__ = ...
    def __init__(self, x: float, y: float) -> None:
        ...
    
    @staticmethod
    def from_polar(angle, radius): # -> _Vec2:
        ...
    
    def __add__(self, other): # -> _Vec2:
        ...
    
    def __sub__(self, other): # -> _Vec2:
        ...
    
    def __mul__(self, other): # -> _Vec2:
        ...
    
    def __truediv__(self, other): # -> _Vec2:
        ...
    
    def __iter__(self): # -> Generator[float, Any, None]:
        ...
    
    def length(self): # -> float:
        """return the length (magnitude) of the vector"""
        ...
    
    def dot(self, other):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def rotated(self, angle: float): # -> _Vec2:
        """
        Returns the new vector resulting when this vector is
        rotated by the given angle in degrees
        """
        ...
    
    def as_tuple(self) -> Point2:
        ...
    


def get_distance(x1: float, y1: float, x2: float, y2: float) -> float:
    """
    Get the distance between two points.

    :param x1: x coordinate of the first point
    :param y1: y coordinate of the first point
    :param x2: x coordinate of the second point
    :param y2: y coordinate of the second point
    :return: Distance between the two points
    """
    ...

def rotate_point(x: float, y: float, cx: float, cy: float, angle_degrees: float) -> Point2:
    """
    Rotate a point around a center.

    :param x: x value of the point you want to rotate
    :param y: y value of the point you want to rotate
    :param cx: x value of the center point you want to rotate around
    :param cy: y value of the center point you want to rotate around
    :param angle_degrees: Angle, in degrees, to rotate
    :return: Return rotated (x, y) pair
    """
    ...

def get_angle_degrees(x1: float, y1: float, x2: float, y2: float) -> float:
    """
    Get the angle in degrees between two points.

    :param x1: x coordinate of the first point
    :param y1: y coordinate of the first point
    :param x2: x coordinate of the second point
    :param y2: y coordinate of the second point
    """
    ...

def get_angle_radians(x1: float, y1: float, x2: float, y2: float) -> float:
    """
    Get the angle in radians between two points.

    :param x1: x coordinate of the first point
    :param y1: y coordinate of the first point
    :param x2: x coordinate of the second point
    :param y2: y coordinate of the second point
    """
    ...

def quaternion_rotation(axis: Tuple[float, float, float], vector: Tuple[float, float, float], angle: float) -> Tuple[float, float, float]:
    """
    Rotate a 3-dimensional vector of any length clockwise around a 3-dimensional unit length vector.

    This method of vector rotation is immune to rotation-lock, however it takes a little more effort
    to find the axis of rotation rather than 3 angles of rotation.
    Ref: https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html.

    :param axis: The unit length vector that will be rotated around
    :param vector: The 3-dimensional vector to be rotated
    :param angle: The angle in degrees to rotate the vector clock-wise by
    :return: A rotated 3-dimension vector with the same length as the argument vector.
    """
    ...

