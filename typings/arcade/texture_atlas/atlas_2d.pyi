"""
This type stub file was generated by pyright.
"""

import PIL.Image
from pathlib import Path
from typing import List, Optional, Sequence, TYPE_CHECKING, Tuple, Union
from contextlib import contextmanager
from PIL import Image
from arcade.gl.framebuffer import Framebuffer
from .base import TextureAtlasBase
from arcade import ArcadeContext, Texture
from arcade.gl import Texture2D
from arcade.texture import ImageData

if TYPE_CHECKING:
    ...
RESIZE_STEP = ...
UV_TEXTURE_WIDTH = ...
LOG = ...
TexCoords = Tuple[float, float, float, float, float, float, float, float]
class AtlasRegion:
    """
    Stores information about where a texture is located.

    The texture coordinates are stored as a tuple of 8 floats
    (4 points, 2 floats each) in the following order:
    upper_left, upper_right, lower_left, lower_right.

    Layout::

        (0, 1)                                 (1, 1)
        +--------------------------------------+
        |          Atlas Texture               |
        |                                      |
        | (2)               (3)                |
        +-----------------+                    |
        |   Image         |                    |
        |                 |                    |
        |                 |                    |
        |                 |                    |
        |                 |                    |
        | (0)             | (1)                |
        +-----------------+--------------------+
        (0, 0)                                 (1, 0)

    :param atlas: The atlas this region belongs to
    :param texture: The arcade texture
    :param x: The x position of the texture
    :param y: The y position of the texture
    :param width: The width of the texture in pixels
    :param height: The height of the texture in pixels
    :param texture_coordinates: The texture coordinates (optional)
    """
    __slots__ = ...
    def __init__(self, atlas: TextureAtlas, x: int, y: int, width: int, height: int, texture_coordinates: Optional[TexCoords] = ...) -> None:
        ...
    
    def verify_image_size(self, image_data: ImageData): # -> None:
        """
        Verify the image has the right size.
        The internal image of a texture can be tampered with
        at any point causing an atlas update to fail.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


class UVData:
    """
    A container for float32 texture coordinates stored in a texture.
    Each texture coordinate has a slot/index in the texture and is
    looked up by a shader to obtain the texture coordinates.

    The purpose of this system is to:
    * Greatly increase the performance of the texture atlas
    * Greatly simplify the system
    * Allow images to move freely around the atlas without having to update the vertex buffers.
      Meaning we can allow re-building and re-sizing. The resize can even
      be done in the GPU by rendering the old atlas into the new one.
    * Avoid spending lots of time packing texture data into buffers
    * Avoid spending lots of buffer memory

    :param ctx: The arcade context
    :param capacity: The number of textures the atlas keeps track of.
                     This is multiplied by 4096. Meaning capacity=2 is 8192 textures.
    """
    def __init__(self, ctx: ArcadeContext, capacity: int) -> None:
        ...
    
    def clone_with_slots(self) -> UVData:
        """
        Clone the UVData with the same texture and slots only.
        We can't lose the global slots when re-building or resizing the atlas.
        """
        ...
    
    @property
    def num_slots(self) -> int:
        """The amount of texture coordinates (x4) this UVData can hold"""
        ...
    
    @property
    def num_free_slots(self) -> int:
        """The amount of free texture coordinates slots"""
        ...
    
    @property
    def texture(self) -> Texture2D:
        """The texture containing the texture coordinates"""
        ...
    
    def get_slot_or_raise(self, name: str) -> int:
        """
        Get the slot for a texture by name or raise an exception

        :param name: The name of the texture
        :return: The slot
        :raises Exception: If the texture is not found
        """
        ...
    
    def get_existing_or_free_slot(self, name: str) -> int:
        """
        Get the slot for a texture by name or a free slot-

        :param name: The name of the texture
        :return: The slot or a free slot
        """
        ...
    
    def free_slot_by_name(self, name: str) -> None:
        """
        Free a slot for a texture by name.

        :param name: The name of the texture
        """
        ...
    
    def set_slot_data(self, slot: int, data: TexCoords) -> None:
        """
        Update the texture coordinates for a slot.

        :param slot: The slot to update
        :param data: The texture coordinates
        """
        ...
    
    def write_to_texture(self) -> None:
        """Write the texture coordinates to the texture if dirty"""
        ...
    


class TextureAtlas(TextureAtlasBase):
    """
    A texture atlas with a size in a context.

    A texture atlas is a large texture containing several textures
    so OpenGL can easily batch draw thousands or hundreds of thousands
    of sprites on one draw operation.

    This is a fairly simple atlas that stores horizontal strips were
    the height of the strip is the texture/image with the larges height.

    Adding a texture to this atlas generates a texture id.
    This id is used the sprite list vertex data to reference what
    texture each sprite is using. The actual texture coordinates
    are located in a float32 texture this atlas is responsible for
    keeping up to date.

    The atlas deals with image and textures. The image is the actual
    image data. The texture is the arcade texture object that contains
    the image and other information about such as transforms.
    Several textures can share the same image with different transforms
    applied. The transforms are simply changing the order of the texture
    coordinates to flip, rotate or mirror the image.

    :param Tuple[int, int] size: The width and height of the atlas in pixels
    :param border: Currently no effect; Should always be 1 to avoid textures bleeding
    :param textures: The texture for this atlas
    :param auto_resize: Automatically resize the atlas when full
    :param ctx: The context for this atlas (will use window context if left empty)
    :param capacity: The number of textures the atlas keeps track of.
                     This is multiplied by 4096. Meaning capacity=2 is 8192 textures.
                     This value can affect the performance of the atlas.
    """
    def __init__(self, size: Tuple[int, int], *, border: int = ..., textures: Optional[Sequence[Texture]] = ..., auto_resize: bool = ..., ctx: Optional[ArcadeContext] = ..., capacity: int = ...) -> None:
        ...
    
    @property
    def width(self) -> int:
        """
        The width of the texture atlas in pixels
        """
        ...
    
    @property
    def height(self) -> int:
        """
        The height of the texture atlas in pixels
        """
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        The width and height of the texture atlas in pixels
        """
        ...
    
    @property
    def max_width(self) -> int:
        """
        The maximum width of the atlas in pixels
        """
        ...
    
    @property
    def max_height(self) -> int:
        """
        The maximum height of the atlas in pixels
        """
        ...
    
    @property
    def max_size(self) -> Tuple[int, int]:
        """
        The maximum size of the atlas in pixels (x, y)
        """
        ...
    
    @property
    def auto_resize(self) -> bool:
        """
        Get or set the auto resize flag for the atlas.
        If enabled the atlas will resize itself when full.
        """
        ...
    
    @auto_resize.setter
    def auto_resize(self, value: bool): # -> None:
        ...
    
    @property
    def border(self) -> int:
        """
        The texture border in pixels
        """
        ...
    
    @property
    def texture(self) -> Texture2D:
        """
        The atlas texture.
        """
        ...
    
    @property
    def image_uv_texture(self) -> Texture2D:
        """
        Texture coordinate texture for images.
        """
        ...
    
    @property
    def texture_uv_texture(self) -> Texture2D:
        """
        Texture coordinate texture for textures.
        """
        ...
    
    @property
    def fbo(self) -> Framebuffer:
        """The framebuffer object for this atlas"""
        ...
    
    @property
    def textures(self) -> List[Texture]:
        """
        All textures instance added to the atlas regardless
        of their internal state. See :py:meth:`unique_textures``
        for textures with unique image data and transformation.
        """
        ...
    
    @property
    def unique_textures(self) -> List[Texture]:
        """
        All unique textures in the atlas.

        These are textures using an image with the same hash
        and the same vertex order. The full list of all textures
        can be found in :py:meth:`textures`.
        """
        ...
    
    @property
    def images(self) -> List[ImageData]:
        """
        Return a list of all the images in the atlas.

        A new list is constructed from the internal weak set of images.
        """
        ...
    
    def add(self, texture: Texture) -> Tuple[int, AtlasRegion]:
        """
        Add a texture to the atlas.

        :param texture: The texture to add
        :return: texture_id, AtlasRegion tuple
        :raises AllocatorException: If there are no room for the texture
        """
        ...
    
    def write_image(self, image: PIL.Image.Image, x: int, y: int) -> None:
        """
        Write a PIL image to the atlas in a specific region.

        :param image: The pillow image
        :param x: The x position to write the texture
        :param y: The y position to write the texture
        """
        ...
    
    def remove(self, texture: Texture) -> None:
        """
        Remove a texture from the atlas.

        This doesn't erase the pixel data from the atlas texture
        itself, but leaves the area unclaimed. The area will be
        reclaimed when the atlas is rebuilt.

        :param texture: The texture to remove
        """
        ...
    
    def update_texture_image(self, texture: Texture): # -> None:
        """
        Updates the internal image of a texture in the atlas texture.
        The new image needs to be the exact same size as the original
        one meaning the texture already need to exist in the atlas.

        This can be used in cases were the image is manipulated in some way
        and we need a quick way to sync these changes to graphics memory.
        This operation is fairly expensive, but still orders of magnitude
        faster than removing the old texture, adding the new one and
        re-building the entire atlas.

        :param texture: The texture to update
        """
        ...
    
    def get_image_region_info(self, hash: str) -> AtlasRegion:
        """
        Get the region info for and image by has

        :param hash: The hash of the image
        :return: The AtlasRegion for the given texture name
        """
        ...
    
    def get_texture_region_info(self, atlas_name: str) -> AtlasRegion:
        """
        Get the region info for a texture by atlas name

        :return: The AtlasRegion for the given texture name
        """
        ...
    
    def get_texture_id(self, texture: Texture) -> int:
        """
        Get the internal id for a Texture in the atlas

        :param atlas_name: The name of the texture in the atlas
        :return: The texture id for the given texture name
        :raises Exception: If the texture is not in the atlas
        """
        ...
    
    def has_texture(self, texture: Texture) -> bool:
        """Check if a texture is already in the atlas"""
        ...
    
    def has_unique_texture(self, texture: Texture) -> bool:
        """
        Check if the atlas already have a texture with the
        same image data and vertex order
        """
        ...
    
    def has_image(self, image_data: ImageData) -> bool:
        """Check if a image is already in the atlas"""
        ...
    
    def resize(self, size: Tuple[int, int]) -> None:
        """
        Resize the atlas on the gpu.

        This will copy the pixel data from the old to the
        new atlas retaining the exact same data.
        This is useful if the atlas was rendered into directly
        and we don't have to transfer each texture individually
        from system memory to graphics memory.

        :param size: The new size
        """
        ...
    
    def rebuild(self) -> None:
        """
        Rebuild the underlying atlas texture.

        This method also tries to organize the textures more efficiently ordering them by size.
        The texture ids will persist so the sprite list don't need to be rebuilt.
        """
        ...
    
    def use_uv_texture(self, unit: int = ...) -> None:
        """
        Bind the texture coordinate texture to a channel.
        In addition this method writes the texture
        coordinate to the texture if the data is stale.
        This is to avoid a full update every time a texture
        is added to the atlas.

        :param unit: The texture unit to bind the uv texture
        """
        ...
    
    @contextmanager
    def render_into(self, texture: Texture, projection: Optional[Tuple[float, float, float, float]] = ...): # -> Generator[Framebuffer, Any, None]:
        """
        Render directly into a sub-section of the atlas.
        The sub-section is defined by the already allocated space
        of the texture supplied in this method.

        By default the projection will be set to match the texture area size
        were `0, 0` is the lower left corner and `width, height` (of texture)
        is the upper right corner.

        This method should should be used with the ``with`` statement::

            with atlas.render_into(texture):
                # Draw commands here

            # Specify projection
            with atlas.render_into(texture, projection=(0, 100, 0, 100))
                # Draw geometry

        :param texture: The texture area to render into
        :param projection: The ortho projection to render with.
            This parameter can be left blank if no projection changes are needed.
            The tuple values are: (left, right, button, top)
        """
        ...
    
    @classmethod
    def create_from_texture_sequence(cls, textures: Sequence[Texture], border: int = ...) -> TextureAtlas:
        """
        Create a texture atlas of a reasonable size from a sequence of textures.

        :param textures: A sequence of textures (list, set, tuple, generator etc.)
        :param border: The border for the atlas in pixels (space between each texture)
        """
        ...
    
    @classmethod
    def calculate_minimum_size(cls, textures: Sequence[Texture], border: int = ...): # -> tuple[int, int]:
        """
        Calculate the minimum atlas size needed to store the
        the provided sequence of textures

        :param textures: Sequence of textures
        :param border: The border around each texture in pixels
        :return: An estimated minimum size as a (width, height) tuple
        """
        ...
    
    def read_texture_image_from_atlas(self, texture: Texture) -> Image.Image:
        """
        Read the pixel data for a texture directly from the atlas texture on the GPU.
        The contents of this image can be altered by rendering into the atlas and
        is useful in situations were you need the updated pixel data on the python side.

        :param texture: The texture to get the image for
        :return: A pillow image containing the pixel data in the atlas
        """
        ...
    
    def update_texture_image_from_atlas(self, texture: Texture) -> None:
        """
        Update the arcade Texture's internal image with the pixel data content
        from the atlas texture on the GPU. This can be useful if you render
        into the atlas and need to update the texture with the new pixel data.

        :param texture: The texture to update
        """
        ...
    
    def to_image(self, flip: bool = ..., components: int = ..., draw_borders: bool = ..., border_color: Tuple[int, int, int] = ...) -> Image.Image:
        """
        Convert the atlas to a Pillow image.

        Borders can also be drawn into the image to visualize the
        regions of the atlas.

        :param flip: Flip the image horizontally
        :param components: Number of components. (3 = RGB, 4 = RGBA)
        :param draw_borders: Draw region borders into image
        :param color: RGB color of the borders
        :return: A pillow image containing the atlas texture
        """
        ...
    
    def show(self, flip: bool = ..., components: int = ..., draw_borders: bool = ..., border_color: Tuple[int, int, int] = ...) -> None:
        """
        Show the texture atlas using Pillow.

        Borders can also be drawn into the image to visualize the
        regions of the atlas.

        :param flip: Flip the image horizontally
        :param components: Number of components. (3 = RGB, 4 = RGBA)
        :param draw_borders: Draw region borders into image
        :param color: RGB color of the borders
        """
        ...
    
    def save(self, path: Union[str, Path], flip: bool = ..., components: int = ..., draw_borders: bool = ..., border_color: Tuple[int, int, int] = ...) -> None:
        """
        Save the texture atlas to a png.

        Borders can also be drawn into the image to visualize the
        regions of the atlas.

        :param path: The path to save the atlas on disk
        :param flip: Flip the image horizontally
        :param components: Number of components. (3 = RGB, 4 = RGBA)
        :param color: RGB color of the borders
        :return: A pillow image containing the atlas texture
        """
        ...
    


