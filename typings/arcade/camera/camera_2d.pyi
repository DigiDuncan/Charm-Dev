"""
This type stub file was generated by pyright.
"""

from typing import Generator, Optional, TYPE_CHECKING, Tuple
from contextlib import contextmanager
from typing_extensions import Self
from arcade.camera.data_types import CameraData, OrthographicProjectionData
from arcade.gl import Framebuffer
from pyglet.math import Vec2, Vec3
from arcade.types import Point, Rect
from arcade.types.vector_like import Point2
from arcade.application import Window

if TYPE_CHECKING:
    ...
__all__ = ['Camera2D']
class Camera2D:
    """
    A simple orthographic camera. Similar to SimpleCamera, but takes better advantage of the new data structures.
    As the Simple Camera is depreciated, any new project should use this camera instead.

    It provides properties to access every important variable for controlling the camera.
    3D properties such as pos, and up are constrained to a 2D plane. There is no access to the
    forward vector (as a property).

    The method fully fulfils both the Camera and Projector protocols.

    There are also ease of use methods for matching the viewport and projector to the window size.

    Provides 4 sets of left, right, bottom, top:

    * View Data, or where the camera is in
    * Projection without zoom scaling.
    * Projection with zoom scaling.
    * Viewport in screen pixels

    .. warning:: Do not replace the ``camera_data`` and ``projection_data``
                 instances after initialization!

    Replacing the camera data and projection data may break controllers. Their
    contents are exposed via properties rather than directly to prevent this.

    :param viewport: A 4-int tuple which defines the pixel bounds which the camera will project to.
    :param position: The 2D position of the camera in the XY plane.
    :param up: A 2D vector which describes which direction is up (defines the +Y-axis of the camera space).
    :param zoom: A scalar value which is inversely proportional to the size of the camera projection.
            i.e. a zoom of 2.0 halves the size of the projection, doubling the perceived size of objects.
    :param projection: A 4-float tuple which defines the world space
                bounds which the camera projects to the viewport.
    :param near: The near clipping plane of the camera.
    :param far: The far clipping plane of the camera.
    :param render_target: The FrameBuffer that the camera uses. Defaults to the screen.
        If the framebuffer is not the default screen nothing drawn after this camera is used will
        show up. The FrameBuffer's internal viewport is ignored.
    :param window: The Arcade Window to bind the camera to.
        Defaults to the currently active window.
    """
    def __init__(self, viewport: Optional[Rect] = ..., position: Optional[Point2] = ..., up: Tuple[float, float] = ..., zoom: float = ..., projection: Optional[Rect] = ..., near: float = ..., far: float = ..., *, scissor: Optional[Rect] = ..., render_target: Optional[Framebuffer] = ..., window: Optional[Window] = ...) -> None:
        ...
    
    @classmethod
    def from_camera_data(cls, *, camera_data: Optional[CameraData] = ..., projection_data: Optional[OrthographicProjectionData] = ..., render_target: Optional[Framebuffer] = ..., viewport: Optional[Rect] = ..., scissor: Optional[Rect] = ..., window: Optional[Window] = ...) -> Self:
        """
        Make a ``Camera2D`` directly from data objects.

        This :py:class:`classmethod` allows advanced users to:

        #. skip or replace the default validation
        #. share ``camera_data`` or ``projection_data`` between cameras

        .. warning:: Be careful when sharing data objects!
                    **Any** action on a camera which changes a shared
                    object changes it for **every** camera which uses
                    the same object.

        .. list-table::
          :header-rows: 1

          * - Shared Value
            - Example Use(s)
          * - ``camera_data``
            - Mini-maps, reflection, and ghosting effects.
          * - ``projection_data``
            - Simplified rendering configuration
          * - ``render_target``
            - Complex rendering setups

        :param camera_data: A :py:class:`~arcade.camera.data.CameraData`
            describing the position, up, forward and zoom.
        :param projection_data:
            A :py:class:`~arcade.camera.data.OrthographicProjectionData`
            which describes the left, right, top, bottom, far, near
            planes and the viewport for an orthographic projection.
        :param render_target: A non-screen
            :py:class:`~arcade.gl.framebuffer.Framebuffer` for this
            camera to draw into. When specified,

            * nothing will draw directly to the screen
            * the buffer's internal viewport will be ignored

        :param viewport:
            A viewport as a :py:class:`~arcade.types.rect.Rect`.
            This overrides any viewport the ``render_target`` may have.
        :param scissor:
            The OpenGL scissor box to use when drawing.
        :param window: The Arcade Window to bind the camera to.
            Defaults to the currently active window.
        """
        ...
    
    @property
    def view_data(self) -> CameraData:
        """The view data for the camera.

        This includes:

        * the position
        * forward vector
        * up direction
        * zoom.

        Camera controllers use this property. You will need to access
        it if you use implement a custom one.
        """
        ...
    
    @property
    def projection_data(self) -> OrthographicProjectionData:
        """The projection data for the camera.

        This is an Orthographic projection. with a
        right, left, top, bottom, near, and far value.

        An easy way to understand the use of the projection is
        that the right value of the projection tells the
        camera what value will be at the right most
        pixel in the viewport.

        Due to the view data having a zoom component
        most use cases will only change the projection
        on screen resize.
        """
        ...
    
    @property
    def position(self) -> Vec2:
        """The 2D world position of the camera along the X and Y axes."""
        ...
    
    @position.setter
    def position(self, _pos: Point2) -> None:
        ...
    
    @property
    def top_left(self) -> Vec2:
        """Get the top left most corner the camera can see"""
        ...
    
    @top_left.setter
    def top_left(self, new_corner: Point2): # -> None:
        ...
    
    @property
    def top_center(self) -> Vec2:
        """Get the top most position the camera can see"""
        ...
    
    @top_center.setter
    def top_center(self, new_top: Point2): # -> None:
        ...
    
    @property
    def top_right(self) -> Vec2:
        """Get the top right most corner the camera can see"""
        ...
    
    @top_right.setter
    def top_right(self, new_corner: Point2): # -> None:
        ...
    
    @property
    def bottom_right(self) -> Vec2:
        """Get the bottom right most corner the camera can see"""
        ...
    
    @bottom_right.setter
    def bottom_right(self, new_corner: Point2): # -> None:
        ...
    
    @property
    def bottom_center(self) -> Vec2:
        """Get the bottom most position the camera can see"""
        ...
    
    @bottom_center.setter
    def bottom_center(self, new_bottom: Point2): # -> None:
        ...
    
    @property
    def bottom_left(self) -> Vec2:
        """Get the bottom left most corner the camera can see"""
        ...
    
    @bottom_left.setter
    def bottom_left(self, new_corner: Point2): # -> None:
        ...
    
    @property
    def center_right(self) -> Vec2:
        """ Get the right most point the camera can see """
        ...
    
    @center_right.setter
    def center_right(self, new_right: Point2): # -> None:
        ...
    
    @property
    def center_left(self) -> Vec2:
        """ Get the left most point the camera can see"""
        ...
    
    @center_left.setter
    def center_left(self, new_left: Point2): # -> None:
        ...
    
    def point_in_view(self, point: Point2) -> bool:
        """
        Take a 2D point in the world, and return whether the point is inside the visible area of the camera.
        """
        ...
    
    @property
    def projection(self) -> Rect:
        """Get/set the left, right, bottom, and top projection values.

        These are world space values which control how the camera
        projects the world onto the pixel space of the current
        :py:attr:`.viewport` area.

        .. warning:: The axis values cannot be equal!

                     * ``left`` cannot equal ``right``
                     * ``bottom`` cannot equal ``top``

        This property raises a :py:class:`~arcade.camera.data_types.ZeroProjectionDimension`
        exception if any axis pairs are equal. You can handle this
        exception as a :py:class:`ValueError`.
        """
        ...
    
    @projection.setter
    def projection(self, value: Rect) -> None:
        ...
    
    @property
    def width(self) -> float:
        """
        The width of the projection from left to right.
        This is in world space coordinates not pixel coordinates.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        you have to calculate the value manually from projection_data
        """
        ...
    
    @width.setter
    def width(self, new_width: float) -> None:
        ...
    
    @property
    def height(self) -> float:
        """
        The height of the projection from bottom to top.
        This is in world space coordinates not pixel coordinates.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        you have to calculate the value manually from projection_data
        """
        ...
    
    @height.setter
    def height(self, new_height: float) -> None:
        ...
    
    @property
    def left(self) -> float:
        """
        The left edge of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        use projection_data.left instead.
        """
        ...
    
    @left.setter
    def left(self, new_left: float) -> None:
        ...
    
    @property
    def right(self) -> float:
        """
        The right edge of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        use projection_data.right instead.
        """
        ...
    
    @right.setter
    def right(self, new_right: float) -> None:
        ...
    
    @property
    def bottom(self) -> float:
        """
        The bottom edge of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        use projection_data.bottom instead.
        """
        ...
    
    @bottom.setter
    def bottom(self, new_bottom: float) -> None:
        ...
    
    @property
    def top(self) -> float:
        """
        The top edge of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS scaled by zoom.
        If this isn't what you want,
        use projection_data.top instead.
        """
        ...
    
    @top.setter
    def top(self, new_top: float) -> None:
        ...
    
    @property
    def projection_near(self) -> float:
        """
        The near plane of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS NOT scaled by zoom.
        """
        ...
    
    @projection_near.setter
    def projection_near(self, new_near: float) -> None:
        ...
    
    @property
    def projection_far(self) -> float:
        """
        The far plane of the projection in world space.
        This is not adjusted with the camera position.

        NOTE this IS NOT scaled by zoom.
        """
        ...
    
    @projection_far.setter
    def projection_far(self, new_far: float) -> None:
        ...
    
    @property
    def viewport(self) -> Rect:
        """Get/set pixels of the ``render_target`` drawn to when active.

        The pixel area is defined as integer pixel coordinates starting
        from the bottom left of ``self.render_target``. They are ordered
        as ``(left, bottom, width, height)``.
        """
        ...
    
    @viewport.setter
    def viewport(self, viewport: Rect) -> None:
        ...
    
    @property
    def scissor(self) -> Optional[Rect]:
        ...
    
    @scissor.setter
    def scissor(self, scissor: Rect): # -> None:
        ...
    
    @property
    def viewport_width(self) -> int:
        """
        The width of the viewport.
        Defines the number of pixels drawn too horizontally.
        """
        ...
    
    @viewport_width.setter
    def viewport_width(self, new_width: int) -> None:
        ...
    
    @property
    def viewport_height(self) -> int:
        """
        The height of the viewport.
        Defines the number of pixels drawn too vertically.
        """
        ...
    
    @viewport_height.setter
    def viewport_height(self, new_height: int) -> None:
        ...
    
    @property
    def viewport_left(self) -> int:
        """
        The left most pixel drawn to on the X axis.
        """
        ...
    
    @viewport_left.setter
    def viewport_left(self, new_left: int) -> None:
        ...
    
    @property
    def viewport_right(self) -> int:
        """
        The right most pixel drawn to on the X axis.
        """
        ...
    
    @viewport_right.setter
    def viewport_right(self, new_right: int) -> None:
        """
        Set the right most pixel drawn to on the X axis.
        This moves the position of the viewport, not change the size.
        """
        ...
    
    @property
    def viewport_bottom(self) -> int:
        """
        The bottom most pixel drawn to on the Y axis.
        """
        ...
    
    @viewport_bottom.setter
    def viewport_bottom(self, new_bottom: int) -> None:
        """
        Set the bottom most pixel drawn to on the Y axis.
        """
        ...
    
    @property
    def viewport_top(self) -> int:
        """
        The top most pixel drawn to on the Y axis.
        """
        ...
    
    @viewport_top.setter
    def viewport_top(self, new_top: int) -> None:
        """
        Set the top most pixel drawn to on the Y axis.
        This moves the position of the viewport, not change the size.
        """
        ...
    
    @property
    def up(self) -> Vec2:
        """
        A 2D vector which describes what is mapped
        to the +Y direction on screen.
        This is equivalent to rotating the screen.
        The base vector is 3D, but the simplified
        camera only provides a 2D view.
        """
        ...
    
    @up.setter
    def up(self, _up: Point2) -> None:
        """
        Set the 2D vector which describes what is
        mapped to the +Y direction on screen.
        This is equivalent to rotating the screen.
        The base vector is 3D, but the simplified
        camera only provides a 2D view.

        NOTE that this is assumed to be normalised.
        """
        ...
    
    @property
    def angle(self) -> float:
        """
        An angle representation of the 2D UP vector.
        This starts with 0 degrees as [0, 1] rotating
        clock-wise.
        """
        ...
    
    @angle.setter
    def angle(self, value: float) -> None:
        """
        Set the 2D UP vector using an angle.
        This starts with 0 degrees as [0, 1]
        rotating clock-wise.
        """
        ...
    
    @property
    def zoom(self) -> float:
        """
        A scalar value which describes
        how much the projection should
        be scaled towards from its center.

        A value of 2.0 causes the projection
        to be half its original size.
        This causes sprites to appear 2.0x larger.
        """
        ...
    
    @zoom.setter
    def zoom(self, _zoom: float) -> None:
        """
        Set the scalar value which describes
        how much the projection should
        be scaled towards from its center.

        A value of 2.0 causes the projection
        to be half its original size.
        This causes sprites to appear 2.0x larger.
        """
        ...
    
    def equalise(self) -> None:
        """
        Forces the projection to match the size of the viewport.
        When matching the projection to the viewport the method keeps
        the projections center in the same relative place.
        """
        ...
    
    def match_screen(self, and_projection: bool = ...) -> None:
        """
        Sets the viewport to the size of the screen.
        Should be called when the screen is resized.

        Args:
            and_projection: Flag whether to also equalise the projection to the viewport.
        """
        ...
    
    def use(self) -> None:
        """
        Set internal projector as window projector,
        and set the projection and view matrix.
        call every time you want to 'look through' this camera.

        If you want to use a 'with' block use activate() instead.
        """
        ...
    
    @contextmanager
    def activate(self) -> Generator[Self, None, None]:
        """
        Set internal projector as window projector,
        and set the projection and view matrix.

        This method works with 'with' blocks.
        After using this method it automatically resets
        the projector to the one previously in use.
        """
        ...
    
    def project(self, world_coordinate: Point) -> Vec2:
        """
        Take a Vec2 or Vec3 of coordinates and return the related screen coordinate
        """
        ...
    
    def unproject(self, screen_coordinate: Point) -> Vec3:
        """
        Take in a pixel coordinate from within
        the range of the window size and returns
        the world space coordinates.

        Essentially reverses the effects of the projector.

        Args:
            screen_coordinate: A 2D position in pixels from the bottom left of the screen.
                               This should ALWAYS be in the range of 0.0 - screen size.
            depth: The depth of the query
        Returns:
            A 3D vector in world space (same as sprites).
            perfect for finding if the mouse overlaps with a sprite or ui element irrespective
            of the camera.
        """
        ...
    


