"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from typing import Generator, Protocol
from typing_extensions import Self
from pyglet.math import Vec2, Vec3
from arcade.types import AsFloat, Point, Point3, Rect

"""Packets of data and base types supporting cameras.

These are placed in their own module to simplify imports due to their
wide usage throughout Arcade's camera code.
"""
__all__ = ['CameraData', 'OrthographicProjectionData', 'PerspectiveProjectionData', 'Projection', 'Projector', 'ZeroProjectionDimension', 'constrain_camera_data', 'duplicate_camera_data']
class ZeroProjectionDimension(ValueError):
    """A projection's dimensions were zero along at least one axis.

    This usually happens because code tried to set one of the following:

    * ``left`` equal to ``right``
    * ``bottom`` equal to ``top``

    You can handle this error as a :py:class:`ValueError`.
    """
    ...


class CameraData:
    """Stores position, orientation, and zoom for a camera.

    This is like where a camera is placed in 3D space.

    Attributes:
        position: A 3D vector which describes where the camera is located.
        up: A 3D vector which describes which direction is up (+y).
        forward: a 3D vector which describes which direction is forwards (+z).
        zoom: A scaler that records the zoom of the camera. While this most often affects the projection matrix
              it allows camera controllers access to the zoom functionality
              without interacting with the projection data.
    """
    __slots__ = ...
    def __init__(self, position: Point3 = ..., up: Point3 = ..., forward: Point3 = ..., zoom: float = ...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def duplicate_camera_data(origin: CameraData): # -> CameraData:
    ...

def constrain_camera_data(data: CameraData, forward_priority: bool = ...): # -> None:
    """
    Ensure that the camera data forward and up vectors are length one,
    and are perpendicular

    :param data: the camera data to constrain
    :param forward_priority: whether up or forward gets constrained
    """
    ...

class OrthographicProjectionData:
    """Describes an Orthographic projection.

    This is by default a Left-handed system. with the X axis going from left to right, The Y axis going from
    bottom to top, and the Z axis going from towards the screen to away from the screen. This can be made
    right-handed by making the near value greater than the far value.

    Attributes:
        left: The left most value, which gets mapped to x = -1.0 (anything below this value is not visible).
        right: The right most value, which gets mapped to x = 1.0 (anything above this value is not visible).
        bottom: The bottom most value, which gets mapped to y = -1.0 (anything below this value is not visible).
        top: The top most value, which gets mapped to y = 1.0 (anything above this value is not visible).
        near: The 'closest' value, which gets mapped to z = -1.0 (anything below this value is not visible).
        far: The 'furthest' value, Which gets mapped to z = 1.0 (anything above this value is not visible).
        viewport: The pixel bounds which will be drawn onto. (left, bottom, width, height)
    """
    __slots__ = ...
    def __init__(self, left: float, right: float, bottom: float, top: float, near: float, far: float) -> None:
        ...
    
    @property
    def left(self) -> float:
        ...
    
    @left.setter
    def left(self, new_left: AsFloat): # -> None:
        ...
    
    @property
    def right(self) -> float:
        ...
    
    @right.setter
    def right(self, new_right: AsFloat): # -> None:
        ...
    
    @property
    def bottom(self) -> float:
        ...
    
    @bottom.setter
    def bottom(self, new_bottom: AsFloat): # -> None:
        ...
    
    @property
    def top(self) -> float:
        ...
    
    @top.setter
    def top(self, new_top: AsFloat): # -> None:
        ...
    
    @property
    def lrbt(self) -> tuple[float, float, float, float]:
        ...
    
    @lrbt.setter
    def lrbt(self, new_lrbt: tuple[float, float, float, float]): # -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def orthographic_from_rect(rect: Rect, near: float, far: float) -> OrthographicProjectionData:
    ...

class PerspectiveProjectionData:
    """Describes a perspective projection.

    Attributes:
        aspect: The aspect ratio of the screen (width over height).
        fov: The field of view in degrees. With the aspect ratio defines
                the size of the projection at any given depth.
        near: The 'closest' value, which gets mapped to z = -1.0 (anything below this value is not visible).
        far: The 'furthest' value, Which gets mapped to z = 1.0 (anything above this value is not visible).
        viewport: The pixel bounds which will be drawn onto. (left, bottom, width, height)
    """
    __slots__ = ...
    def __init__(self, aspect: float, fov: float, near: float, far: float) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Projection(Protocol):
    """Matches the data universal in Arcade's projection data objects.

    There are multiple types of projections used in games, but all the
    common ones share key features. This :py:class:`~typing.Protocol`:

    #. Defines those shared elements
    #. Annotates these in code for both humans and automated type
       checkers

    The specific implementations which match it are used inside of
    implementations of Arcade's :py:class:`.Projector` behavior. All
    of these projectors rely on a ``viewport`` as well as ``near`` and
    ``far`` values.

    The ``viewport`` is measured in screen pixels. By default, the
    conventions for this are the same as the rest of Arcade and
    OpenGL:

    * X is measured rightward from left of the screen
    * Y is measured up from the bottom of the screen

    Although the ``near`` and ``far`` values are describe the cutoffs
    for what the camera sees in world space, the exact meaning differs
    between projection type.

    .. list-table::
       :header-rows: 1

       * - Common Projection Type
         - Meaning of ``near`` & ``far``

       * - Simple Orthographic
         - The Z position in world space

       * - Perspective & Isometric
         - Where the rear and front clipping planes sit along a
           camera's :py:attr:`.CameraData.forward` vector.

    """
    near: float
    far: float
    ...


class Projector(Protocol):
    """Projects from world coordinates to viewport pixel coordinates.

    Projectors also support converting in the opposite direction from
    screen pixel coordinates to world space coordinates.

    The two key spatial methods which do this are:

    .. list-table::
       :header-rows: 1

       * - Method
         - Action

       * - :py:meth:`.project`
         - Turn world coordinates into pixel coordinates relative
           to the origin (bottom left by default).

       * - :py:meth:`.unproject`
         - Convert screen pixel coordinates into world space.

    .. note: Every :py:class:`.Camera` is also a kind of projector.

    The other required methods are for helping manage which camera is
    currently used to draw.

    """
    def use(self) -> None:
        """Set the GL context to use this projector and its settings.

        .. warning:: You may be looking for:py:meth:`.activate`!

                     This method only sets rendering state for a given
                     projector. Since it doesn't restore any afterward,
                     it's easy to misuse in ways which can cause bugs
                     or temporarily break a game's rendering until
                     relaunch. For reliable, automatic clean-up see
                     the :py:meth:`.activate` method instead.

        If you are implementing your own custom projector, this method
        should only:

        #. Set the Arcade :py:class:`~arcade.Window`'s
           :py:attr:`~arcade.Window.current_camera` to this object
        #. Calculate any required view and projection matrices
        #. Set any resulting values on the current
           :py:class:`~arcade.context.ArcadeContext`, including the:

           * :py:attr:`~arcade.context.ArcadeContext.viewport`
           * :py:attr:`~arcade.context.ArcadeContext.view_matrix`
           * :py:attr:`~arcade.context.ArcadeContext.projection_matrix`

        This method should **never** handle cleanup. That is the
        responsibility of :py:attr:`.activate`.

        """
        ...
    
    @contextmanager
    def activate(self) -> Generator[Self, None, None]:
        ...
    
    def project(self, world_coordinate: Point) -> Vec2:
        """
        Take a Vec2 or Vec3 of coordinates and return the related screen coordinate
        """
        ...
    
    def unproject(self, screen_coordinate: Point) -> Vec3:
        """
        Take in a pixel coordinate and return the associated world coordinate

        Essentially reverses the effects of the projector.

        Args:
            screen_coordinate: A 2D position in pixels should generally be inside the range of the active viewport.
            depth: The depth of the query. This can be though of how far along the forward vector
                   the final coord will be.
        Returns:
            A 3D vector in world space.
        """
        ...
    


