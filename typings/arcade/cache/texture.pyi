"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, TYPE_CHECKING, Union
from pathlib import Path
from arcade import Texture
from arcade.hitbox import HitBoxAlgorithm

if TYPE_CHECKING:
    ...
class TextureBucket:
    """
    A simple dict based cache for textures.
    """
    def __init__(self) -> None:
        ...
    
    def put(self, name: str, texture: Texture) -> None:
        ...
    
    def get(self, name: str) -> Optional[Texture]:
        ...
    
    def delete(self, name: str, ignore_error: bool = ...) -> None:
        ...
    
    def delete_by_value(self, texture: Texture, ignore_error: bool = ...) -> None:
        ...
    
    def clear(self) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    


class WeakTextureBucket(TextureBucket):
    """
    A simple WeakValueDictionary based cache for textures.
    """
    def __init__(self) -> None:
        ...
    


class TextureCache:
    """
    A cache for arcade textures.

    The creation of a texture is an expensive operation for several reasons.
    * Creating a texture from a file has a cost
    * Creating a texture from a PIL image has a cost
    * Once the texture is created it's expensive to calculate hit box points

    This cache is intended to reduce the cost of creating textures by reusing
    existing ones. We also re-use the internal images on the existing textures
    for making different configurations of the same texture such as flipped
    and rotated versions including textures with different hit box configurations
    for the same image.
    """
    def __init__(self) -> None:
        ...
    
    def put(self, texture: Texture, *, file_path: Optional[Union[str, Path]] = ..., strong: bool = ...) -> None:
        """
        Add a texture to the cache.

        :param texture: The texture to add
        :param file_path: The path to the file the texture was loaded from
        :param strong: If True the cache will keep the texture alive
        """
        ...
    
    def get(self, name: str) -> Optional[Texture]:
        """
        Get a texture from the cache by cache name

        :param name: The cache name of the texture
        :return: The texture if found, otherwise None
        """
        ...
    
    def get_with_config(self, hash: str, hit_box_algorithm: HitBoxAlgorithm) -> Optional[Texture]:
        """
        Attempts to find a texture with a specific configuration.

        :param image_data: The image data to search for
        :param hit_box_algorithm: The hit box algorithm to search for
        :return: The texture if found, otherwise None
        """
        ...
    
    def get_file(self, file_path: str) -> Optional[Texture]:
        """
        Get a texture from the cache by file path.

        :param file_path: The path to the file the texture was loaded from
        """
        ...
    
    def delete(self, texture_or_name: Union[Texture, str], ignore_error: bool = ...) -> None:
        """
        Delete a texture from the cache by cache name.

        :param texture_or_name: The texture or cache name to delete
        :param ignore_error: If True, ignore errors when deleting
        """
        ...
    
    def clear(self) -> None:
        """Clear the cache"""
        ...
    
    def get_all_textures(self) -> List[Texture]:
        """Get all unique textures in the cache"""
        ...
    
    def __len__(self) -> int:
        """Count the number of unique textures"""
        ...
    
    def __contains__(self, texture: Texture) -> bool:
        ...
    
    def __iter__(self): # -> Iterator[Texture]:
        ...
    
    def __getitem__(self, name: str) -> Optional[Texture]:
        ...
    
    def __setitem__(self, name: str, texture: Texture) -> None:
        ...
    
    def __delitem__(self, name: str) -> None:
        ...
    


