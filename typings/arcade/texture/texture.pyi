"""
This type stub file was generated by pyright.
"""

import PIL.Image
from typing import Any, Dict, Optional, TYPE_CHECKING, Tuple, Type, Union
from pathlib import Path
from arcade import TextureAtlas
from arcade.hitbox.base import HitBoxAlgorithm
from arcade.texture.transforms import Transform
from arcade.types import Point2List, RGBA255
from arcade.types.rect import Rect

if TYPE_CHECKING:
    ...
__all__ = ["ImageData", "Texture"]
LOG = ...
class ImageData:
    """
    A class holding the image for a texture with other metadata such as the hash.
    This information is used internally by the texture atlas to identify unique textures.

    If a hash is not provided, it will be calculated.
    It's important that all hashes are of the same type.
    By default, the hash is calculated using the sha256 algorithm.

    The ability to provide a hash directly is mainly there
    for ensuring we can load and save texture atlases to disk.

    :param image: The image for this texture
    :param hash: The hash of the image
    """
    __slots__ = ...
    hash_func = ...
    def __init__(self, image: PIL.Image.Image, hash: Optional[str] = ...) -> None:
        ...
    
    @classmethod
    def calculate_hash(cls, image: PIL.Image.Image) -> str:
        """
        Calculates the hash of an image.

        The algorithm used is defined by the ``hash_func`` class variable.
        """
        ...
    
    @property
    def width(self) -> int:
        """
        The width of the image
        """
        ...
    
    @property
    def height(self) -> int:
        """
        The height of the image
        """
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        The size of the image
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Texture:
    """
    An arcade.Texture is simply a wrapper for image data as a Pillow image
    and the hit box data for this image used in collision detection.
    Usually created by the :class:`load_texture` or :class:`load_textures` commands.

    :param image: The image or ImageData for this texture
    :param hit_box_algorithm: The algorithm to use for calculating the hit box.
    :param hit_box_points: A list of hitbox points for the texture to use (Optional).
                                     Completely overrides the hit box algorithm.
    :param hash: Optional unique name for the texture. Can be used to make this texture
                     globally unique. By default the hash of the pixel data is used.
    """
    __slots__ = ...
    def __init__(self, image: Union[PIL.Image.Image, ImageData], *, hit_box_algorithm: Optional[HitBoxAlgorithm] = ..., hit_box_points: Optional[Point2List] = ..., hash: Optional[str] = ..., **kwargs) -> None:
        ...
    
    @property
    def properties(self) -> Dict[str, Any]:
        """
        A dictionary of properties for this texture.
        This can be used to store any data you want.

        :return: Dict[str, Any]
        """
        ...
    
    @property
    def cache_name(self) -> str:
        """
        The name of the texture used for caching (read only).

        :return: str
        """
        ...
    
    @classmethod
    def create_cache_name(cls, *, hash: str, hit_box_algorithm: HitBoxAlgorithm, vertex_order: Tuple[int, int, int, int] = ...) -> str:
        """
        Create a cache name for the texture.

        :param image_data: The image data
        :param hit_box_algorithm: The hit box algorithm
        :param hit_box_args: The hit box algorithm arguments
        :param Tuple[int, int, int, int] vertex_order: The vertex order
        :return: str
        """
        ...
    
    @classmethod
    def create_atlas_name(cls, hash: str, vertex_order: Tuple[int, int, int, int] = ...): # -> str:
        ...
    
    @classmethod
    def create_image_cache_name(cls, path: Union[str, Path], crop: Tuple[int, int, int, int] = ...): # -> str:
        ...
    
    @property
    def atlas_name(self) -> str:
        """
        The name of the texture used for the texture atlas (read only).

        :return: str
        """
        ...
    
    @property
    def file_path(self) -> Optional[Path]:
        """
        A Path object to the file this texture was loaded from

        :return: Path
        """
        ...
    
    @file_path.setter
    def file_path(self, path: Optional[Path]): # -> None:
        ...
    
    @property
    def crop_values(self) -> Optional[Tuple[int, int, int, int]]:
        """
        The crop values used to create this texture in the referenced file

        :return: Tuple[int, int, int, int]
        """
        ...
    
    @crop_values.setter
    def crop_values(self, crop: Optional[Tuple[int, int, int, int]]): # -> None:
        ...
    
    @property
    def image(self) -> PIL.Image.Image:
        """
        Get or set the image of the texture.

        .. warning::

            This is an advanced function. Be absolutely sure
            you know the consequences of changing the image.
            It can cause problems with the texture atlas and
            hit box points.

        :param image: The image to set
        """
        ...
    
    @image.setter
    def image(self, image: PIL.Image.Image): # -> None:
        ...
    
    @property
    def image_data(self) -> ImageData:
        """
        The image data of the texture (read only).

        This is a simple wrapper around the image
        containing metadata like hash and is used
        to determine the uniqueness of the image
        in texture atlases.

        :return: ImageData
        """
        ...
    
    @property
    def width(self) -> int:
        """
        The virtual width of the texture in pixels.
        This can be different from the actual width
        if the texture has been transformed or the
        size have been set manually.

        """
        ...
    
    @width.setter
    def width(self, value: int): # -> None:
        ...
    
    @property
    def height(self) -> int:
        """
        The virtual width of the texture in pixels.

        This can be different from the actual width
        if the texture has been transformed or the
        size have been set manually.

        """
        ...
    
    @height.setter
    def height(self, value: int): # -> None:
        ...
    
    @property
    def size(self) -> Tuple[int, int]:
        """
        The virtual size of the texture in pixels.

        This can be different from the actual width
        if the texture has been transformed or the
        size have been set manually.

        """
        ...
    
    @size.setter
    def size(self, value: Tuple[int, int]): # -> None:
        ...
    
    @property
    def hit_box_points(self) -> Point2List:
        """
        Get the hit box points for this texture.

        Custom hit box points must be supplied during texture creation
        and should ideally not be changed after creation.

        :return: PointList
        """
        ...
    
    @property
    def hit_box_algorithm(self) -> HitBoxAlgorithm:
        """
        (read only) The algorithm used to calculate the hit box for this texture.
        """
        ...
    
    @classmethod
    def create_filled(cls, name: str, size: Tuple[int, int], color: RGBA255) -> Texture:
        """
        Create a filled texture. This is an alias for :py:meth:`create_empty`.

        :param name: Name of the texture
        :param Tuple[int, int] size: Size of the texture
        :param color: Color of the texture
        :return: Texture
        """
        ...
    
    @classmethod
    def create_empty(cls, name: str, size: Tuple[int, int], color: RGBA255 = ...) -> Texture:
        """
        Create a texture with all pixels set to transparent black.

        The hit box of the returned Texture will be set to a rectangle
        with the dimensions in ``size`` because there is no non-blank
        pixel data to calculate a hit box.

        :param name: The unique name for this texture
        :param size: The xy size of the internal image

        This function has multiple uses, including:

            - Allocating space in texture atlases
            - Generating custom cached textures from component images

        The internal image can be altered with Pillow draw commands and
        then written/updated to a texture atlas. This works best for
        infrequent changes such as generating custom cached sprites.
        For frequent texture changes, you should instead render directly
        into the texture atlas.

        .. warning::

           If you plan to alter images using Pillow, read its
           documentation thoroughly! Some of the functions can have
           unexpected behavior.

           For example, if you want to draw one or more images that
           contain transparency onto a base image that also contains
           transparency, you will likely need to use
           `PIL.Image.alpha_composite`_ as part of your solution.
           Otherwise, blending may behave in unexpected ways.

           This is especially important for customizable characters.

        .. _PIL.Image.alpha_composite: https://pillow.readthedocs.io/en/stable/\
                                       reference/Image.html#PIL.Image.alpha_composite

        Be careful of your RAM usage when using this function. The
        Texture this method returns will have a new internal RGBA
        Pillow image which uses 4 bytes for every pixel in it.
        This will quickly add up if you create many large Textures.

        If you want to create more than one blank texture with the same
        dimensions, you can save CPU time and RAM by calling this
        function once, then passing the ``image`` attribute of the
        resulting Texture object to the class constructor for each
        additional blank Texture instance you would like to create.
        This can be especially helpful if you are creating multiple
        large Textures.

        """
        ...
    
    def flip_left_right(self) -> Texture:
        """
        Flip the texture left to right / horizontally.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def flip_top_bottom(self) -> Texture:
        """
        Flip the texture top to bottom / vertically.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def flip_horizontally(self) -> Texture:
        """
        Flip the texture left to right / horizontally.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def flip_vertically(self) -> Texture:
        """
        Flip the texture top to bottom / vertically.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def flip_diagonally(self) -> Texture:
        """
        Returns a new texture that is flipped diagonally from this texture.
        This is an alias for :func:`transpose`.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def transpose(self) -> Texture:
        """
        Returns a new texture that is transposed from this texture.
        This flips the texture diagonally from lower right to upper left.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def transverse(self) -> Texture:
        """
        Returns a new texture that is transverse from this texture.
        This flips the texture diagonally from lower left to upper right.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def rotate_90(self, count: int = ...) -> Texture:
        """
        Rotate the texture by a given number of 90 degree steps.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :param count: Number of 90 degree steps to rotate.
        :return: Texture
        """
        ...
    
    def rotate_180(self) -> Texture:
        """
        Rotate the texture 180 degrees.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def rotate_270(self) -> Texture:
        """
        Rotate the texture 270 degrees.

        This returns a new texture with the same image data, but
        has updated hit box data and a transform that will be
        applied to the image when it's drawn (GPU side).

        :return: Texture
        """
        ...
    
    def transform(self, transform: Type[Transform]) -> Texture:
        """
        Create a new texture with the given transform applied.

        :param transform: Transform to apply
        :return: New texture
        """
        ...
    
    def crop(self, x: int, y: int, width: int, height: int) -> Texture:
        """
        Create a new texture from a sub-section of this texture.

        If the crop is the same size as the original texture or
        the crop is 0 width or height, the original texture is
        returned.

        :param x: X position to start crop
        :param y: Y position to start crop
        :param width: Width of crop
        :param height: Height of crop
        :param cache: If True, the cropped texture will be cached
        :return: Texture
        """
        ...
    
    def remove_from_atlases(self) -> None:
        """
        Remove this texture from all atlases.
        """
        ...
    
    def add_atlas_ref(self, atlas: TextureAtlas) -> None:
        """
        Add a reference to an atlas that this texture is in.
        """
        ...
    
    def remove_atlas_ref(self, atlas: TextureAtlas) -> None:
        """
        Remove a reference to an atlas that this texture is in.
        """
        ...
    
    def remove_from_cache(self, ignore_error: bool = ...) -> None:
        """
        Remove this texture from the cache.

        :param ignore_error: If True, ignore errors if the texture is not in the cache
        :return: None
        """
        ...
    
    @staticmethod
    def validate_crop(image: PIL.Image.Image, x: int, y: int, width: int, height: int) -> None:
        """
        Validate the crop values for a given image.
        """
        ...
    
    def draw_sized(self, center_x: float, center_y: float, width: float, height: float, angle: float = ..., alpha: int = ...): # -> None:
        """
        Draw a texture with a specific width and height.

        .. warning:: This is a very slow method of drawing a texture,
                     and should be used sparingly. The method simply
                     creates a sprite internally and draws it.

        :param center_x: X position to draw texture
        :param center_y: Y position to draw texture
        :param width: Width to draw texture
        :param height: Height to draw texture
        :param angle: Angle to draw texture
        :param alpha: Alpha value to draw texture
        """
        ...
    
    def draw_scaled(self, center_x: float, center_y: float, scale: float = ..., angle: float = ..., alpha: int = ...): # -> None:
        """
        Draw the texture.

        .. warning:: This is a very slow method of drawing a texture,
                     and should be used sparingly. The method simply
                     creates a sprite internally and draws it.

        :param center_x: X location of where to draw the texture.
        :param center_y: Y location of where to draw the texture.
        :param scale: Scale to draw rectangle. Defaults to 1.
        :param angle: Angle to rotate the texture by.
        :param alpha: The transparency of the texture ``(0-255)``.
        """
        ...
    
    def draw_rect(self, rect: Rect, alpha: int = ...): # -> None:
        """
        Draw the texture.

        .. warning:: This is a very slow method of drawing a texture,
                     and should be used sparingly. The method simply
                     creates a sprite internally and draws it.

        :param rect: A Rect to draw this texture to.
        :param alpha: The transparency of the texture ``(0-255)``.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __del__(self): # -> None:
        ...
    


