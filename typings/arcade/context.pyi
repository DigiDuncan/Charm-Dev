"""
This type stub file was generated by pyright.
"""

import pyglet
from pathlib import Path
from typing import Any, Dict, Iterable, Optional, Sequence, Tuple, Union
from contextlib import contextmanager
from PIL import Image
from arcade.gl import Context
from arcade.gl.compute_shader import ComputeShader
from arcade.gl.program import Program
from arcade.gl.texture import Texture2D
from arcade.gl.framebuffer import Framebuffer
from pyglet.math import Mat4
from arcade.texture_atlas import TextureAtlas

"""
Arcade's version of the OpenGL Context.
Contains pre-loaded programs
"""
__all__ = ["ArcadeContext"]
class ArcadeContext(Context):
    """
    An OpenGL context implementation for Arcade with added custom features.
    This context is normally accessed through :py:attr:`arcade.Window.ctx`.

    Pyglet users can use the base Context class and extend that as they please.

    **This is part of the low level rendering API in arcade
    and is mainly for more advanced usage**

    :param window: The pyglet window
    :param gc_mode: The garbage collection mode for opengl objects.
                        ``auto`` is just what we would expect in python
                        while ``context_gc`` (default) requires you to call ``Context.gc()``.
                        The latter can be useful when using multiple threads when
                        it's not clear what thread will gc the object.
    """
    atlas_size: Tuple[int, int] = ...
    def __init__(self, window: pyglet.window.Window, gc_mode: str = ..., gl_api: str = ...) -> None:
        ...
    
    def reset(self) -> None:
        """
        Reset context flags and other states.
        This is mostly used in unit testing.
        """
        ...
    
    def bind_window_block(self) -> None:
        """
        Binds the projection and view uniform buffer object.
        This should always be bound to index 0 so all shaders
        have access to them.
        """
        ...
    
    @property
    def default_atlas(self) -> TextureAtlas:
        """
        The default texture atlas. This is created when arcade is initialized.
        All sprite lists will use use this atlas unless a different atlas
        is passed in the :py:class:`arcade.SpriteList` constructor.

        :type: TextureAtlas
        """
        ...
    
    @property
    def viewport(self) -> Tuple[int, int, int, int]:
        """
        Get or set the viewport for the currently active framebuffer.
        The viewport simply describes what pixels of the screen
        OpenGL should render to. Normally it would be the size of
        the window's framebuffer::

            # 4:3 screen
            ctx.viewport = 0, 0, 800, 600
            # 1080p
            ctx.viewport = 0, 0, 1920, 1080
            # Using the current framebuffer size
            ctx.viewport = 0, 0, *ctx.screen.size

        :type: tuple (x, y, width, height)
        """
        ...
    
    @viewport.setter
    def viewport(self, value: Tuple[int, int, int, int]): # -> None:
        ...
    
    @property
    def projection_matrix(self) -> Mat4:
        """
        Get the current projection matrix.
        This 4x4 float32 matrix is calculated by cameras.

        This property simply gets and sets pyglet's projection matrix.

        :type: pyglet.math.Mat4
        """
        ...
    
    @projection_matrix.setter
    def projection_matrix(self, value: Mat4): # -> None:
        ...
    
    @property
    def view_matrix(self) -> Mat4:
        """
        Get the current view matrix.
        This 4x4 float32 matrix is calculated when setting :py:attr:`~arcade.ArcadeContext.view_matrix_2d`.

        This property simply gets and sets pyglet's view matrix.

        :type: pyglet.math.Mat4
        """
        ...
    
    @view_matrix.setter
    def view_matrix(self, value: Mat4): # -> None:
        ...
    
    @contextmanager
    def pyglet_rendering(self): # -> Generator[None, Any, None]:
        """
        Context manager for doing rendering with pyglet
        ensuring context states are reverted. This
        affects things like blending.
        """
        ...
    
    def load_program(self, *, vertex_shader: Union[str, Path], fragment_shader: Optional[Union[str, Path]] = ..., geometry_shader: Optional[Union[str, Path]] = ..., tess_control_shader: Optional[Union[str, Path]] = ..., tess_evaluation_shader: Optional[Union[str, Path]] = ..., common: Iterable[Union[str, Path]] = ..., defines: Optional[Dict[str, Any]] = ..., varyings: Optional[Sequence[str]] = ..., varyings_capture_mode: str = ...) -> Program:
        """
        Create a new program given a file names that contain the vertex shader and
        fragment shader. Note that fragment and geometry shader are optional for
        when transform shaders are loaded.

        This method also supports the resource handles.

        Example::

            # The most common use case if having a vertex and fragment shader
            program = window.ctx.load_program(
                vertex_shader="vert.glsl",
                fragment_shader="frag.glsl",
            )

        :param vertex_shader: path to vertex shader
        :param fragment_shader: path to fragment shader (optional)
        :param geometry_shader: path to geometry shader (optional)
        :param tess_control_shader: Tessellation Control Shader
        :param tess_evaluation_shader: Tessellation Evaluation Shader
        :param common: Common files to be included in all shaders
        :param defines: Substitute ``#define`` values in the source
        :param varyings: The name of the out attributes in a transform shader.
                                                 This is normally not necessary since we auto detect them,
                                                 but some more complex out structures we can't detect.
        :param varyings_capture_mode: The capture mode for transforms.
                                          ``"interleaved"`` means all out attribute will be written to a single buffer.
                                          ``"separate"`` means each out attribute will be written separate buffers.
                                          Based on these settings the `transform()` method will accept a single
                                          buffer or a list of buffer.
        """
        ...
    
    def load_compute_shader(self, path: Union[str, Path], common: Iterable[Union[str, Path]] = ...) -> ComputeShader:
        """
        Loads a compute shader from file. This methods supports
        resource handles.

        Example::

            ctx.load_compute_shader(":shader:compute/do_work.glsl")

        :param path: Path to texture
        :param common: Common source injected into compute shader
        """
        ...
    
    def load_texture(self, path: Union[str, Path], *, flip: bool = ..., build_mipmaps: bool = ..., internal_format: Optional[int] = ..., compressed: bool = ...) -> Texture2D:
        """
        Loads and creates an OpenGL 2D texture.
        Currently, all textures are converted to RGBA for simplicity.

        Example::

            # Load a texture in current working directory
            texture = window.ctx.load_texture("background.png")

            # Load a texture using Arcade resource handle
            texture = window.ctx.load_texture(":textures:background.png")

            # Load and compress a texture
            texture = window.ctx.load_texture(
                ":textures:background.png",
                internal_format=gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
                compressed=True,
            )

        :param path: Path to texture
        :param flip: Flips the image upside down
        :param build_mipmaps: Build mipmaps for the texture
        :param internal_format: The internal format of the texture. This can be used to
            override the default internal format when using sRGBA or compressed textures.
        :param compressed: If the internal format is a compressed format meaning your
            texture will be compressed by the GPU.
        """
        ...
    
    def shader_inc(self, source: str) -> str:
        """
        Parse a shader source looking for ``#include`` directives and
        replace them with the contents of the included file.

        The ``#include`` directive must be on its own line and the file
        and the path should use a resource handle.

        Example::

            #include :my_shader:lib/common.glsl

        :param source: Shader
        """
        ...
    
    def get_framebuffer_image(self, fbo: Framebuffer, components: int = ..., flip: bool = ...) -> Image.Image:
        """
        Shortcut method for reading data from a framebuffer and converting it to a PIL image.

        :param fbo: Framebuffer to get image from
        :param components: Number of components to read
        :param flip: Flip the image upside down
        """
        ...
    


