"""
This type stub file was generated by pyright.
"""

from typing import Generator, Iterable, List, Optional, TYPE_CHECKING, Union
from arcade import View
from arcade.types.rect import Rect

if TYPE_CHECKING:
    ...
__all__ = ["Section", "SectionManager"]
class Section:
    """
    A Section represents a rectangular portion of the viewport
    Events are dispatched to the section based on it's position on the screen.

    :param left: the left position of this section
    :param bottom: the bottom position of this section
    :param width: the width of this section
    :param height: the height of this section
    :param name: the name of this section
    :param Union[bool, Iterable] accept_keyboard_keys: whether or not this section captures keyboard keys through.
        keyboard events. If the param is an iterable means the keyboard keys that are captured in press/release
        events: for example: [arcade.key.UP, arcade.key.DOWN] will only capture this two keys
    :param Union[bool, Iterable] accept_mouse_events: whether or not this section captures mouse events.
        If the param is an iterable means the mouse events that are captured.
        for example: ['on_mouse_press', 'on_mouse_release'] will only capture this two events.
    :param prevent_dispatch: a list of event names that will not be dispatched to subsequent
        sections. You can pass None (default) or {True} to prevent the dispatch of all events.
    :param prevent_dispatch_view: a list of event names that will not be dispatched to the view.
        You can pass None (default) or {True} to prevent the dispatch of all events to the view.
    :param local_mouse_coordinates: if True the section mouse events will receive x, y coordinates section
        related to the section dimensions and position (not related to the screen)
    :param enabled: if False the section will not capture any events
    :param modal: if True the section will be a modal section: will prevent updates and event captures on
        other sections. Will also draw last (on top) but capture events first.
    :param draw_order: The order this section will have when on_draw is called.
        The lower the number the earlier this will get draw.
        This can be different from the event capture order or the on_update order which is defined by the insertion
        order.
    """
    def __init__(self, left: int, bottom: int, width: int, height: int, *, name: Optional[str] = ..., accept_keyboard_keys: Union[bool, Iterable] = ..., accept_mouse_events: Union[bool, Iterable] = ..., prevent_dispatch: Optional[Iterable] = ..., prevent_dispatch_view: Optional[Iterable] = ..., local_mouse_coordinates: bool = ..., enabled: bool = ..., modal: bool = ..., draw_order: int = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def view(self): # -> View | None:
        """ The view this section is set on """
        ...
    
    @property
    def section_manager(self) -> Optional[SectionManager]:
        """ Returns the section manager """
        ...
    
    @property
    def enabled(self) -> bool:
        """ Enables or disables this section """
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    
    @property
    def modal(self) -> bool:
        """
        Returns the modal state (Prevent the following sections from
        receiving input events and updating)
        """
        ...
    
    @property
    def draw_order(self) -> int:
        """
        Returns the draw order state
        The lower the number the earlier this section will get draw
        """
        ...
    
    @draw_order.setter
    def draw_order(self, value: int) -> None:
        """
        Sets this section draw order
        The lower the number the earlier this section will get draw
        """
        ...
    
    @property
    def left(self) -> int:
        """ Left edge of this section """
        ...
    
    @left.setter
    def left(self, value: int): # -> None:
        ...
    
    @property
    def bottom(self) -> int:
        """ The bottom edge of this section """
        ...
    
    @bottom.setter
    def bottom(self, value: int): # -> None:
        ...
    
    @property
    def width(self) -> int:
        """ The width of this section """
        ...
    
    @width.setter
    def width(self, value: int): # -> None:
        ...
    
    @property
    def height(self) -> int:
        """ The height of this section """
        ...
    
    @height.setter
    def height(self, value: int): # -> None:
        ...
    
    @property
    def right(self) -> int:
        """ Right edge of this section """
        ...
    
    @right.setter
    def right(self, value: int): # -> None:
        ...
    
    @property
    def top(self) -> int:
        """ Top edge of this section """
        ...
    
    @top.setter
    def top(self, value: int): # -> None:
        ...
    
    @property
    def rect(self) -> Rect:
        ...
    
    @property
    def window(self): # -> Window:
        """ The view window """
        ...
    
    def overlaps_with(self, section: Section) -> bool:
        """ Checks if this section overlaps with another section """
        ...
    
    def mouse_is_on_top(self, x: int, y: int) -> bool:
        """ Check if the current mouse position is on top of this section """
        ...
    
    def should_receive_mouse_event(self, x: int, y: int) -> bool:
        """ Check if the current section should receive a mouse event at a given position """
        ...
    
    def get_xy_screen_relative(self, section_x: int, section_y: int): # -> tuple[int, int]:
        """ Returns screen coordinates from section coordinates """
        ...
    
    def get_xy_section_relative(self, screen_x: int, screen_y: int): # -> tuple[int, int]:
        """ returns section coordinates from screen coordinates """
        ...
    
    def on_draw(self): # -> None:
        ...
    
    def on_update(self, delta_time: float): # -> None:
        ...
    
    def on_resize(self, width: int, height: int): # -> None:
        ...
    
    def on_mouse_press(self, x: int, y: int, button: int, modifiers: int): # -> None:
        ...
    
    def on_mouse_release(self, x: int, y: int, button: int, modifiers: int): # -> None:
        ...
    
    def on_mouse_motion(self, x: int, y: int, dx: int, dy: int): # -> None:
        ...
    
    def on_mouse_scroll(self, x: int, y: int, scroll_x: int, scroll_y: int): # -> None:
        ...
    
    def on_mouse_drag(self, x: int, y: int, dx: int, dy: int, _buttons: int, _modifiers: int): # -> None:
        ...
    
    def on_mouse_enter(self, x: int, y: int): # -> None:
        ...
    
    def on_mouse_leave(self, x: int, y: int): # -> None:
        ...
    
    def on_key_press(self, symbol: int, modifiers: int): # -> None:
        ...
    
    def on_key_release(self, _symbol: int, _modifiers: int): # -> None:
        ...
    
    def on_show_section(self): # -> None:
        ...
    
    def on_hide_section(self): # -> None:
        ...
    


class SectionManager:
    """
    This manages the different Sections a View has.
    Actions such as dispatching the events to the correct Section, draw order, etc.
    """
    def __init__(self, view: View) -> None:
        ...
    
    @property
    def sections(self) -> List[Section]:
        """ Property that returns the list of sections """
        ...
    
    @property
    def has_sections(self) -> bool:
        """ Returns true if this section manager has sections """
        ...
    
    @property
    def is_current_view(self) -> bool:
        """
        Returns if this section manager view is the current on the view window
        a.k.a.: is the view that is currently being shown
        """
        ...
    
    def disable(self) -> None:
        """
        Disable all sections
        Disabling a section will trigger section.on_hide_section
        """
        ...
    
    def enable(self) -> None:
        """
        Enables all sections
        Enabling a section will trigger section.on_show_section
        """
        ...
    
    def get_section_by_name(self, name: str) -> Optional[Section]:
        """
        Returns the first section with the given name
        :param name: the name of the section you want
        :return: the first section with the provided name. None otherwise
        """
        ...
    
    def add_section(self, section: Section, at_index: Optional[int] = ..., at_draw_order: Optional[int] = ...) -> None:
        """
        Adds a section to this Section Manager
        Will trigger section.on_show_section if section is enabled

        :param section: the section to add to this section manager
        :param at_index: inserts the section at that index for event capture and update events. If None at the end
        :param at_draw_order: inserts the section in a specific draw order. Overwrites section.draw_order
        """
        ...
    
    def remove_section(self, section: Section) -> None:
        """
        Removes a section from this section manager

        :param section: the section to remove
        """
        ...
    
    def sort_section_event_order(self) -> None:
        """ This will sort sections on event capture order (and update) based on insertion order and section.modal """
        ...
    
    def sort_sections_draw_order(self) -> None:
        """ This will sort sections on draw order based on section.draw_order and section.modal """
        ...
    
    def clear_sections(self) -> None:
        """ Removes all sections and calls on_hide_section for each one if enabled """
        ...
    
    def on_update(self, delta_time: float) -> None:
        """
        Called on each event loop.

        :param delta_time: the delta time since this method was called last time
        """
        ...
    
    def on_draw(self) -> None:
        """
        Called on each event loop to draw
        It automatically calls camera.use() for each section that has a camera and resets the camera
        effects by calling the default SectionManager camera afterwards if needed.
        The SectionManager camera defaults to a camera that has the viewport and projection for the whole screen
        """
        ...
    
    def on_resize(self, width: int, height: int) -> None:
        """
        Called when the window is resized.

        :param width: the new width of the screen
        :param height: the new height of the screen
        """
        ...
    
    def disable_all_keyboard_events(self) -> None:
        """ Removes the keyboard event handling from all sections """
        ...
    
    def get_first_section(self, x: int, y: int, *, event_capture: bool = ...) -> Optional[Section]:
        """
        Returns the first section based on x,y position

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param event_capture: True will use event capture dimensions, False will use section draw size
        :return: a section if match the params otherwise None
        """
        ...
    
    def get_sections(self, x: int, y: int, *, event_capture: bool = ...) -> Generator[Section, None, None]:
        """
        Returns a list of sections based on x,y position

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param event_capture: True will use event capture dimensions, False will use section draw size
        :return: a generator with the sections that match the params
        """
        ...
    
    def dispatch_mouse_event(self, event: str, x: int, y: int, *args, current_section: Optional[Section] = ..., **kwargs) -> Optional[bool]:
        """
        Generic method to dispatch mouse events to the correct Sections

        :param event: the mouse event name to dispatch
        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param current_section: the section this mouse event should be delivered to. If None, will retrive all
                                sections that should recieve this event based on x, y coordinates
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def dispatch_keyboard_event(self, event: str, *args, **kwargs) -> Optional[bool]:
        """
        Generic method to dispatch keyboard events to the correct sections

        :param event: the keyboard event name to dispatch
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_press(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        Triggers the on_mouse_press event on the appropiate sections or view

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_release(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        Triggers the on_mouse_release event on the appropiate sections or view

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def dispatch_mouse_enter_leave_events(self, event_origin: str, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        This helper method will dispatch mouse enter / leave events to sections
        based on 'on_mouse_motion' and 'on_mouse_drag' events.
        Will also dispatch the event (event_origin) that called this method

        :param event_origin: the mouse event name that called this method. This event will be called here.
        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_motion(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        This method dispatches the on_mouse_motion and also calculates if on_mouse_enter/leave should be fired

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_drag(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        This method dispatches the on_mouse_drag and also calculates if on_mouse_enter/leave should be fired

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_scroll(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        Triggers the on_mouse_scroll event on the appropiate sections or view

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_enter(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        Triggered when the mouse enters the window space
        Will trigger on_mouse_enter on the appropiate sections or view

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_mouse_leave(self, x: int, y: int, *args, **kwargs) -> Optional[bool]:
        """
        Triggered when the mouse leaves the window space
        Will trigger on_mouse_leave on the appropiate sections or view

        :param x: the x axis coordinate
        :param y: the y axis coordinate
        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_key_press(self, *args, **kwargs) -> Optional[bool]:
        """
        Triggers the on_key_press event on the appropiate sections or view

        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_key_release(self, *args, **kwargs) -> Optional[bool]:
        """
        Triggers the on_key_release event on the appropiate sections or view

        :param args: any other position arguments that should be deliverd to the dispatched event
        :param kwargs: any other keyword arguments that should be delivered to the dispatched event
        :return: EVENT_HANDLED or EVENT_UNHANDLED, or whatever the dispatched method returns
        """
        ...
    
    def on_show_view(self) -> None:
        """
        Called when the view is shown
        The View.on_show_view is called before this by the Window.show_view method
        """
        ...
    
    def on_hide_view(self) -> None:
        """
        Called when the view is hide
        The View.on_hide_view is called before this by the Window.hide_view method
        """
        ...
    


