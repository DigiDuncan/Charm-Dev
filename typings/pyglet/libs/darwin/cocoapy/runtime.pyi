"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from ctypes import *
from .cocoatypes import *

__LP64__ = ...
__i386__ = ...
__arm64__ = ...
if sizeof(c_void_p) == 4:
    c_ptrdiff_t = ...
else:
    c_ptrdiff_t = ...
lib = ...
if lib is None:
    lib = ...
objc = ...
libc = ...
if not __arm64__:
    ...
if not __arm64__:
    ...
if not __arm64__:
    ...
class OBJC_METHOD_DESCRIPTION(Structure):
    _fields_ = ...


OBJC_ASSOCIATION_ASSIGN = ...
OBJC_ASSOCIATION_RETAIN = ...
OBJC_ASSOCIATION_COPY = ...
def ensure_bytes(x): # -> bytes:
    ...

def get_selector(name): # -> c_void_p:
    ...

def get_class(name): # -> c_void_p:
    ...

def get_object_class(obj): # -> c_void_p:
    ...

def get_metaclass(name): # -> c_void_p:
    ...

def get_superclass_of_object(obj): # -> c_void_p:
    ...

def x86_should_use_stret(restype): # -> bool:
    """Try to figure out when a return type will be passed on stack."""
    ...

def should_use_fpret(restype): # -> bool:
    """Determine if objc_msgSend_fpret is required to return a floating point type."""
    ...

def send_message(receiver, selName, *args, **kwargs): # -> Any | c_void_p:
    ...

class OBJC_SUPER(Structure):
    _fields_ = ...


OBJC_SUPER_PTR = ...
def send_super(receiver, selName, *args, superclass_name=..., **kwargs): # -> c_void_p | Any:
    ...

cfunctype_table = ...
def parse_type_encoding(encoding): # -> list[Any]:
    """Takes a type encoding string and outputs a list of the separated type codes.
    Currently does not handle unions or bitfields and strips out any field width
    specifiers or type specifiers from the encoding.  For Python 3.2+, encoding is
    assumed to be a bytes object and not unicode.

    Examples:
    parse_type_encoding('^v16@0:8') --> ['^v', '@', ':']
    parse_type_encoding('{CGSize=dd}40@0:8{CGSize=dd}16Q32') --> ['{CGSize=dd}', '@', ':', '{CGSize=dd}', 'Q']
    """
    ...

def cfunctype_for_encoding(encoding): # -> type[_FuncPointer]:
    ...

def create_subclass(superclass, name): # -> c_void_p:
    ...

def register_subclass(subclass): # -> None:
    ...

def add_method(cls, selName, method, types): # -> _FuncPointer:
    ...

def add_ivar(cls, name, vartype): # -> Any:
    ...

def set_instance_variable(obj, varname, value, vartype): # -> None:
    ...

def get_instance_variable(obj, varname, vartype):
    ...

class ObjCMethod:
    """This represents an unbound Objective-C method (really an IMP)."""
    typecodes = ...
    cfunctype_table = ...
    def __init__(self, method) -> None:
        """Initialize with an Objective-C Method pointer.  We then determine
        the return type and argument type information of the method."""
        ...
    
    def ctype_for_encoding(self, encoding): # -> type[c_byte] | type[c_int] | type[c_short] | type[c_long] | type[c_longlong] | type[c_ubyte] | type[c_uint] | type[c_ushort] | type[c_ulong] | type[c_ulonglong] | type[c_float] | type[c_double] | type[c_bool] | type[c_char_p] | type[c_void_p] | type[NSPoint] | type[NSSize] | type[NSRect] | type[NSRange] | type[py_object[Any]] | type[_Pointer[Any]] | None:
        """Return ctypes type for an encoded Objective-C type."""
        ...
    
    def get_prototype(self): # -> type[_FuncPointer]:
        """Returns a ctypes CFUNCTYPE for the method."""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def get_callable(self): # -> _FuncPointer:
        """Returns a python-callable version of the method's IMP."""
        ...
    
    def __call__(self, objc_id, *args): # -> ObjCInstance | ObjCClass | Any | None:
        """Call the method with the given id and arguments.  You do not need
        to pass in the selector as an argument since it will be automatically
        provided."""
        ...
    


class ObjCBoundMethod:
    """This represents an Objective-C method (an IMP) which has been bound
    to some id which will be passed as the first parameter to the method."""
    def __init__(self, method, objc_id) -> None:
        """Initialize with a method and ObjCInstance or ObjCClass object."""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __call__(self, *args):
        """Call the method with the given arguments."""
        ...
    


class ObjCClass:
    """Python wrapper for an Objective-C class."""
    _registered_classes = ...
    def __new__(cls, class_name_or_ptr): # -> Self:
        """Create a new ObjCClass instance or return a previously created
        instance for the given Objective-C class.  The argument may be either
        the name of the class to retrieve, or a pointer to the class."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def cache_instance_methods(self): # -> None:
        """Create and store python representations of all instance methods
        implemented by this class (but does not find methods of superclass)."""
        ...
    
    def cache_class_methods(self): # -> None:
        """Create and store python representations of all class methods
        implemented by this class (but does not find methods of superclass)."""
        ...
    
    def get_instance_method(self, name): # -> ObjCMethod | None:
        """Returns a python representation of the named instance method,
        either by looking it up in the cached list of methods or by searching
        for and creating a new method object."""
        ...
    
    def get_class_method(self, name): # -> ObjCMethod | None:
        """Returns a python representation of the named class method,
        either by looking it up in the cached list of methods or by searching
        for and creating a new method object."""
        ...
    
    def __getattr__(self, name): # -> ObjCBoundMethod | ObjCMethod:
        """Returns a callable method object with the given name."""
        ...
    


class _AutoreleasepoolManager:
    def __init__(self) -> None:
        ...
    
    @property
    def count(self): # -> int:
        """Number of total pools. Not including global."""
        ...
    
    def create(self, pool): # -> None:
        ...
    
    def delete(self, pool): # -> None:
        ...
    


_arp_manager = ...
_dealloc_argtype = ...
class ObjCInstance:
    """Python wrapper for an Objective-C instance."""
    pool = ...
    retained = ...
    _cached_objects = ...
    def __new__(cls, object_ptr, cache=...): # -> Self | None:
        """Create a new ObjCInstance or return a previously created one
        for the given object_ptr which should be an Objective-C id."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, name): # -> ObjCBoundMethod:
        """Returns a callable method object with the given name."""
        ...
    


def get_cached_instances(): # -> list[Any]:
    """For debug purposes, return a list of instance names.
    Useful for debugging if an object is leaking."""
    ...

def convert_method_arguments(encoding, args): # -> list[Any]:
    """Used by ObjCSubclass to convert Objective-C method arguments to
    Python values before passing them on to the Python-defined method."""
    ...

class ObjCSubclass:
    """Use this to create a subclass of an existing Objective-C class.
    It consists primarily of function decorators which you use to add methods
    to the subclass."""
    def __init__(self, superclass, name, register=...) -> None:
        ...
    
    def register(self): # -> None:
        """Register the new class with the Objective-C runtime."""
        ...
    
    def add_ivar(self, varname, vartype): # -> Any:
        """Add instance variable named varname to the subclass.
        varname should be a string.
        vartype is a ctypes type.
        The class must be registered AFTER adding instance variables."""
        ...
    
    def add_method(self, method, name, encoding): # -> None:
        ...
    
    def add_class_method(self, method, name, encoding): # -> None:
        ...
    
    def rawmethod(self, encoding): # -> Callable[..., Any]:
        """Decorator for instance methods without any fancy shenanigans.
        The function must have the signature f(self, cmd, *args)
        where both self and cmd are just pointers to objc objects."""
        ...
    
    def method(self, encoding): # -> Callable[..., Callable[..., Any]]:
        """Function decorator for instance methods."""
        ...
    
    def classmethod(self, encoding): # -> Callable[..., Callable[..., Any]]:
        """Function decorator for class methods."""
        ...
    


class DeallocationObserver_Implementation:
    DeallocationObserver = ...
    @DeallocationObserver.rawmethod('@@')
    def initWithObject_(self, cmd, objc_ptr): # -> int | Any | None:
        ...
    
    @DeallocationObserver.rawmethod('v')
    def dealloc(self, cmd): # -> None:
        ...
    
    @DeallocationObserver.rawmethod('v')
    def finalize(self, cmd): # -> None:
        ...
    


@contextmanager
def AutoReleasePool(): # -> Generator[None, Any, None]:
    """Use objc_autoreleasePoolPush/Pop because NSAutoreleasePool is no longer recommended:
        https://developer.apple.com/documentation/foundation/nsautoreleasepool
    @autoreleasepool blocks are compiled into the below function calls behind the scenes.
    Call them directly to mimic the Objective C behavior.
    """
    ...

