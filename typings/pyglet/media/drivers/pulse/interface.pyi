"""
This type stub file was generated by pyright.
"""

import ctypes
from typing import Any, Callable, Dict, Optional, TYPE_CHECKING, Tuple, TypeVar, Union
from pyglet.media.drivers.pulse import lib_pulseaudio as pa
from pyglet.media.exceptions import MediaException
from pyglet.media.codecs import AudioFormat

if TYPE_CHECKING:
    ...
T = TypeVar('T')
PulseAudioStreamSuccessCallback = Callable[[ctypes.POINTER(pa.pa_stream), int, Any], Any]
PulseAudioStreamRequestCallback = Callable[[ctypes.POINTER(pa.pa_stream), int, Any], Any]
PulseAudioStreamNotifyCallback = Callable[[ctypes.POINTER(pa.pa_stream), Any], Any]
PulseAudioContextSuccessCallback = Callable[[ctypes.POINTER(pa.pa_context), int, Any], Any]
_debug = ...
_UINT32_MAX = ...
_SIZE_T_MAX = ...
PA_INVALID_INDEX = ...
PA_INVALID_WRITABLE_SIZE = ...
def get_uint32_or_none(value: int) -> Optional[int]:
    ...

def get_bool_or_none(value: int) -> Optional[bool]:
    ...

def get_ascii_str_or_none(value: Optional[bytes]) -> Optional[str]:
    ...

class Proplist:
    def __init__(self, ini_data: Optional[Dict[str, Union[bytes, str]]] = ...) -> None:
        ...
    
    def __setitem__(self, k, v): # -> None:
        ...
    
    def __delitem__(self, k): # -> None:
        ...
    
    def delete(self) -> None:
        ...
    


class PulseAudioException(MediaException):
    def __init__(self, error_code: int, message: str) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...


class _MainloopLock:
    def __init__(self, mainloop: PulseAudioMainloop) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, _exc_type, _ecx_value, _tb): # -> None:
        ...
    


class PulseAudioMainloop:
    def __init__(self) -> None:
        ...
    
    def start(self) -> None:
        """Start running the mainloop."""
        ...
    
    def delete(self) -> None:
        """Clean up the mainloop."""
        ...
    
    def lock_(self) -> None:
        """Lock the threaded mainloop against events.  Required for all
        calls into PA."""
        ...
    
    def unlock(self) -> None:
        """Unlock the mainloop thread."""
        ...
    
    def signal(self) -> None:
        """Signal the mainloop thread to break from a wait."""
        ...
    
    def wait(self) -> None:
        """Unlock and then Wait for a signal from the locked mainloop.
        It's important to note that the PA mainloop lock is reentrant, yet this method only
        releases one lock.
        Before returning, the lock is reacquired.
        """
        ...
    
    def create_context(self) -> PulseAudioContext:
        """Construct and return a new context in this mainloop.
        Will grab the lock.
        """
        ...
    


class PulseAudioMainloopChild:
    def __init__(self, mainloop: PulseAudioMainloop) -> None:
        ...
    


class PulseAudioContext(PulseAudioMainloopChild):
    """Basic object for a connection to a PulseAudio server."""
    _state_name = ...
    def __init__(self, mainloop: PulseAudioMainloop, name: bytes) -> None:
        ...
    
    def delete(self) -> None:
        """Completely shut down pulseaudio client. Will lock."""
        ...
    
    @property
    def is_ready(self) -> bool:
        ...
    
    @property
    def is_failed(self) -> bool:
        ...
    
    @property
    def is_terminated(self) -> bool:
        ...
    
    @property
    def server(self) -> Optional[str]:
        ...
    
    @property
    def protocol_version(self) -> Optional[str]:
        ...
    
    @property
    def server_protocol_version(self) -> Optional[str]:
        ...
    
    @property
    def is_local(self) -> Optional[bool]:
        ...
    
    def connect(self, server: Optional[bytes] = ...) -> None:
        """Connect the context to a PulseAudio server.

        Will grab the mainloop lock.

        :Parameters:
            `server` : bytes
                Server to connect to, or ``None`` for the default local
                server (which may be spawned as a daemon if no server is
                found).
        """
        ...
    
    def create_stream(self, audio_format: AudioFormat) -> PulseAudioStream:
        """
        Create a new audio stream.
        """
        ...
    
    def set_input_volume(self, stream: PulseAudioStream, volume: float) -> PulseAudioOperation:
        """
        Set the volume for a stream.
        """
        ...
    
    def check(self, result: T) -> T:
        ...
    
    def check_not_null(self, value: T) -> T:
        ...
    
    def check_ptr_not_null(self, value: T) -> T:
        ...
    
    def raise_error(self) -> None:
        ...
    


class PulseAudioStream(PulseAudioMainloopChild):
    """PulseAudio audio stream."""
    _state_name = ...
    def __init__(self, context: PulseAudioContext, audio_format: AudioFormat) -> None:
        ...
    
    def create_sample_spec(self, audio_format: AudioFormat) -> pa.pa_sample_spec:
        """
        Create a PulseAudio sample spec from pyglet audio format.
        """
        ...
    
    def delete(self) -> None:
        """If connected, disconnect, and delete the stream."""
        ...
    
    @property
    def is_unconnected(self) -> bool:
        ...
    
    @property
    def is_creating(self) -> bool:
        ...
    
    @property
    def is_ready(self) -> bool:
        ...
    
    @property
    def is_failed(self) -> bool:
        ...
    
    @property
    def is_terminated(self) -> bool:
        ...
    
    def get_writable_size(self) -> int:
        ...
    
    def is_corked(self) -> bool:
        ...
    
    def get_sample_spec(self) -> pa.pa_sample_spec:
        ...
    
    def connect_playback(self, tlength: int = ..., minreq: int = ...) -> None:
        ...
    
    def begin_write(self, nbytes: Optional[int] = ...) -> Tuple[ctypes.c_void_p, int]:
        ...
    
    def cancel_write(self) -> None:
        ...
    
    def write(self, data, length: int, seek_mode=...) -> int:
        ...
    
    def update_timing_info(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def get_timing_info(self) -> Optional[pa.pa_timing_info]:
        """
        Retrieves the stream's timing_info struct,
        or None if it does not exist.
        Note that ctypes creates a copy of the struct, meaning it will
        be safe to use with an unlocked mainloop.
        """
        ...
    
    def trigger(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def prebuf(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def flush(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def resume(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def pause(self, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def update_sample_rate(self, sample_rate: int, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> PulseAudioOperation:
        ...
    
    def set_write_callback(self, f: PulseAudioStreamRequestCallback) -> None:
        ...
    
    def set_underflow_callback(self, f: PulseAudioStreamNotifyCallback) -> None:
        ...
    


class PulseAudioOperation(PulseAudioMainloopChild):
    """An asynchronous PulseAudio operation.
    Can be waited for, where it will run until completion or cancellation.
    Remember to `delete()` it with the mainloop lock held, otherwise
    it will be leaked.
    """
    _state_name = ...
    def __init__(self, callback_lump, pa_operation: pa.pa_operation) -> None:
        ...
    
    def delete(self) -> None:
        """Unref and delete the operation."""
        ...
    
    def cancel(self): # -> Self:
        """Cancel the operation."""
        ...
    
    def wait(self): # -> Self:
        """Wait until the operation is either done or cancelled."""
        ...
    
    @property
    def is_running(self) -> bool:
        ...
    
    @property
    def is_done(self) -> bool:
        ...
    
    @property
    def is_cancelled(self) -> bool:
        ...
    


class PulseAudioContextSuccessCallbackLump:
    def __init__(self, context: PulseAudioContext, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> None:
        ...
    


class PulseAudioStreamSuccessCallbackLump:
    def __init__(self, context: PulseAudioContext, callback: Optional[PulseAudioContextSuccessCallback] = ...) -> None:
        ...
    


