"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta, abstractmethod

_debug = ...
class AbstractAudioPlayer(metaclass=ABCMeta):
    """Base class for driver audio players to be used by the high-level
    player. Relies on a thread to regularly call a `work` method in order
    for it to operate.
    """
    audio_sync_required_measurements = ...
    audio_desync_time_critical = ...
    audio_desync_time_minor = ...
    audio_minor_desync_correction_time = ...
    audio_buffer_length = ...
    def __init__(self, source, player) -> None:
        """Create a new audio player.

        :Parameters:
            `source` : `Source`
                Source to play from.
            `player` : `Player`
                Player to receive EOS and video frame sync events.

        """
        ...
    
    def on_driver_destroy(self): # -> None:
        """Called before the audio driver is going to be destroyed (a planned destroy)."""
        ...
    
    def on_driver_reset(self): # -> None:
        """Called after the audio driver has been re-initialized."""
        ...
    
    def set_source(self, source): # -> None:
        """Change the player's source for a new one.
        It must be of the same audio format.
        Will clear the player, make sure you paused it beforehand.
        """
        ...
    
    @abstractmethod
    def prefill_audio(self): # -> None:
        """Prefill the audio buffer with audio data.

        This method is called before the audio player starts in order to
        have it play as soon as possible.
        """
        ...
    
    @abstractmethod
    def work(self): # -> None:
        """Ran regularly by the worker thread. This method should fill up
        the player's buffers if required, and dispatch any necessary events.
        """
        ...
    
    @abstractmethod
    def play(self): # -> None:
        """Begin playback."""
        ...
    
    @abstractmethod
    def stop(self): # -> None:
        """Stop (pause) playback."""
        ...
    
    @abstractmethod
    def clear(self): # -> None:
        """Clear all buffered data and prepare for replacement data.

        The player must be stopped before calling this method.
        """
        ...
    
    @abstractmethod
    def delete(self): # -> None:
        """Stop playing and clean up all resources used by player."""
        ...
    
    @abstractmethod
    def get_play_cursor(self): # -> None:
        """Get this player's most recent play cursor/read index/byte offset,
        starting from the last clear operation or initialization.

        ``0`` is an acceptable return value when unavailable or unknown.
        """
        ...
    
    def get_time(self): # -> Any:
        """Retrieve the time in the current source the player is at, in seconds.
        By default, calculated using :meth:`get_play_cursor`, divided by the
        bytes per second played.
        """
        ...
    
    def append_events(self, start_index, events): # -> None:
        """Append the given :class:`MediaEvent`s to the events deque using
        the current source's audio format and the supplied ``start_index``
        to convert their timestamps to dispatch indices.

        The high level player's ``last_seek_time`` will be subtracted from
        each event's timestamp.
        """
        ...
    
    def dispatch_media_events(self, until_cursor): # -> None:
        """Dispatch all :class:`MediaEvent`s whose index is less than or equal
        to the specified ``until_cursor`` (which should be a very recent play
        cursor position).
        Please note that :attr:`_compensated_bytes` will be subtracted from
        the passed ``until_cursor``.
        """
        ...
    
    def get_audio_time_diff(self, audio_time): # -> tuple[Any, Literal[True]] | tuple[Any, Literal[False]] | tuple[Literal[0], Literal[False]]:
        """Query the difference between the provided time and the high
        level `Player`'s master clock.

        The time difference returned is calculated as an average on previous
        audio time differences.

        Return a tuple of the bytes the player is off by, aligned to correspond
        to an integer number of audio frames, as well as bool designating
        whether the difference is extreme. If it is, it should be rectified
        immediately and all previous measurements will have been cleared.

        This method will return ``0, False`` if the difference is not
        significant or ``audio_time`` is ``None``.

        :rtype: int, bool
        """
        ...
    
    def set_volume(self, volume): # -> None:
        """See `Player.volume`."""
        ...
    
    def set_position(self, position): # -> None:
        """See :py:attr:`~pyglet.media.Player.position`."""
        ...
    
    def set_min_distance(self, min_distance): # -> None:
        """See `Player.min_distance`."""
        ...
    
    def set_max_distance(self, max_distance): # -> None:
        """See `Player.max_distance`."""
        ...
    
    def set_pitch(self, pitch): # -> None:
        """See :py:attr:`~pyglet.media.Player.pitch`."""
        ...
    
    def set_cone_orientation(self, cone_orientation): # -> None:
        """See `Player.cone_orientation`."""
        ...
    
    def set_cone_inner_angle(self, cone_inner_angle): # -> None:
        """See `Player.cone_inner_angle`."""
        ...
    
    def set_cone_outer_angle(self, cone_outer_angle): # -> None:
        """See `Player.cone_outer_angle`."""
        ...
    
    def set_cone_outer_gain(self, cone_outer_gain): # -> None:
        """See `Player.cone_outer_gain`."""
        ...
    


class AbstractAudioDriver(metaclass=ABCMeta):
    @abstractmethod
    def create_audio_player(self, source, player): # -> None:
        ...
    
    @abstractmethod
    def get_listener(self): # -> None:
        ...
    
    @abstractmethod
    def delete(self): # -> None:
        ...
    


class MediaEvent:
    """Representation of a media event.

    These events are used internally by some audio driver implementation to
    communicate events to the :class:`~pyglet.media.player.Player`.
    One example is the ``on_eos`` event.

    Args:
        event (str): Event description.
        timestamp (float): The time when this event happens.
        *args: Any required positional argument to go along with this event.
    """
    __slots__ = ...
    def __init__(self, event, timestamp=..., *args) -> None:
        ...
    
    def sync_dispatch_to_player(self, player): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    


