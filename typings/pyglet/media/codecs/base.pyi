"""
This type stub file was generated by pyright.
"""

import ctypes
from typing import BinaryIO, List, Optional, TYPE_CHECKING, Union
from pyglet.image import AbstractImage
from pyglet.image.animation import Animation
from pyglet.media.codecs import MediaEncoder
from pyglet.media.drivers.base import MediaEvent
from pyglet.media.player import Player

if TYPE_CHECKING:
    ...
class AudioFormat:
    """Audio details.

    An instance of this class is provided by sources with audio tracks.  You
    should not modify the fields, as they are used internally to describe the
    format of data provided by the source.

    Args:
        channels (int): The number of channels: 1 for mono or 2 for stereo
            (pyglet does not yet support surround-sound sources).
        sample_size (int): Bits per sample; only 8 or 16 are supported.
        sample_rate (int): Samples per second (in Hertz).
    """
    def __init__(self, channels: int, sample_size: int, sample_rate: int) -> None:
        ...
    
    def align(self, num_bytes: int) -> int:
        """Align a given amount of bytes to the audio frame size of this
        audio format, downwards.
        """
        ...
    
    def align_ceil(self, num_bytes: int) -> int:
        """Align a given amount of bytes to the audio frame size of this
        audio format, upwards.
        """
        ...
    
    def timestamp_to_bytes_aligned(self, timestamp: float) -> int:
        """Given a timestamp, return the amount of bytes that an emitter with
        this audio format would have to have played to reach it, aligned
        to the audio frame size.
        """
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class VideoFormat:
    """Video details.

    An instance of this class is provided by sources with a video stream. You
    should not modify the fields.

    Note that the sample aspect has no relation to the aspect ratio of the
    video image.  For example, a video image of 640x480 with sample aspect 2.0
    should be displayed at 1280x480.  It is the responsibility of the
    application to perform this scaling.

    Args:
        width (int): Width of video image, in pixels.
        height (int): Height of video image, in pixels.
        sample_aspect (float): Aspect ratio (width over height) of a single
            video pixel.
        frame_rate (float): Frame rate (frames per second) of the video.

            .. versionadded:: 1.2
    """
    def __init__(self, width: int, height: int, sample_aspect: float = ...) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


class AudioData:
    """A single packet of audio data.

    This class is used internally by pyglet.

    Args:
        data (bytes, ctypes array, or supporting buffer protocol): Sample data.
        length (int): Size of sample data, in bytes.
        timestamp (float): Time of the first sample, in seconds.
        duration (float): Total data duration, in seconds.
        events (List[:class:`pyglet.media.drivers.base.MediaEvent`]): List of events
            contained within this packet. Events are timestamped relative to
            this audio packet.

    .. deprecated:: 2.0.10
            `timestamp` and `duration` are unused and will be removed eventually.
    """
    __slots__ = ...
    def __init__(self, data: Union[bytes, ctypes.Array], length: int, timestamp: float = ..., duration: float = ..., events: Optional[List[MediaEvent]] = ...) -> None:
        ...
    


class SourceInfo:
    """Source metadata information.

    Fields are the empty string or zero if the information is not available.

    Args:
        title (str): Title
        author (str): Author
        copyright (str): Copyright statement
        comment (str): Comment
        album (str): Album name
        year (int): Year
        track (int): Track number
        genre (str): Genre

    .. versionadded:: 1.2
    """
    title = ...
    author = ...
    copyright = ...
    comment = ...
    album = ...
    year = ...
    track = ...
    genre = ...


class Source:
    """An audio and/or video source.

    Args:
        audio_format (:class:`.AudioFormat`): Format of the audio in this
            source, or ``None`` if the source is silent.
        video_format (:class:`.VideoFormat`): Format of the video in this
            source, or ``None`` if there is no video.
        info (:class:`.SourceInfo`): Source metadata such as title, artist,
            etc; or ``None`` if the` information is not available.

            .. versionadded:: 1.2

    Attributes:
        is_player_source (bool): Determine if this source is a player
            current source.

            Check on a :py:class:`~pyglet.media.player.Player` if this source
            is the current source.
    """
    _duration = ...
    _players: List[Player] = ...
    audio_format = ...
    video_format = ...
    info = ...
    is_player_source = ...
    @property
    def duration(self) -> float:
        """float: The length of the source, in seconds.

        Not all source durations can be determined; in this case the value
        is ``None``.

        Read-only.
        """
        ...
    
    def play(self) -> Player:
        """Play the source.

        This is a convenience method which creates a Player for
        this source and plays it immediately.

        Returns:
            :class:`.Player`
        """
        ...
    
    def get_animation(self) -> Animation:
        """
        Import all video frames into memory.

        An empty animation will be returned if the source has no video.
        Otherwise, the animation will contain all unplayed video frames (the
        entire source, if it has not been queued on a player). After creating
        the animation, the source will be at EOS (end of stream).

        This method is unsuitable for videos running longer than a
        few seconds.

        .. versionadded:: 1.1

        Returns:
            :class:`pyglet.image.Animation`
        """
        ...
    
    def get_next_video_timestamp(self) -> Optional[float]:
        """Get the timestamp of the next video frame.

        .. versionadded:: 1.1

        Returns:
            float: The next timestamp, or ``None`` if there are no more video
            frames.
        """
        ...
    
    def get_next_video_frame(self) -> Optional[AbstractImage]:
        """Get the next video frame.

        .. versionadded:: 1.1

        Returns:
            :class:`pyglet.image.AbstractImage`: The next video frame image,
            or ``None`` if the video frame could not be decoded or there are
            no more video frames.
        """
        ...
    
    def save(self, filename: str, file: Optional[BinaryIO] = ..., encoder: Optional[MediaEncoder] = ...) -> None:
        """Save this Source to a file.

        :Parameters:
            `filename` : str
                Used to set the file format, and to open the output file
                if `file` is unspecified.
            `file` : file-like object or None
                File to write audio data to.
            `encoder` : MediaEncoder or None
                If unspecified, all encoders matching the filename extension
                are tried.  If all fail, the exception from the first one
                attempted is raised.

        """
        ...
    
    def is_precise(self) -> bool:
        """bool: Whether this source is considered precise.

        ``x`` bytes on source ``s`` are considered aligned if
        ``x % s.audio_format.bytes_per_frame == 0``, so there'd be no partial
        audio frame in the returned data.

        A source is precise if - for an aligned request of ``x`` bytes - it
        returns:\\

          - If ``x`` or more bytes are available, ``x`` bytes.
          - If not enough bytes are available anymore, ``r`` bytes where
            ``r < x`` and ``r`` is aligned.

        A source is **not** precise if it does any of these:

          - Return less than ``x`` bytes for an aligned request of ``x``
            bytes although data still remains so that an additional request
            would return additional :class:`.AudioData` / not ``None``.
          - Return more bytes than requested.
          - Return an unaligned amount of bytes for an aligned request.

        pyglet's internals are guaranteed to never make unaligned
        requests, or requests of less than 1024 bytes.

        If this method returns ``False``, pyglet will wrap the source in an
        alignment-forcing buffer creating additional overhead.

        If this method is overridden to return ``True`` although the source
        does not comply with the requirements above, audio playback may be
        negatively impacted at best and memory access violations occurr at
        worst.

        :Returns:
            bool: Whether the source is precise.
        """
        ...
    
    def seek(self, timestamp: float) -> None:
        """Seek to given timestamp.

        Args:
            timestamp (float): Time where to seek in the source. The
                ``timestamp`` will be clamped to the duration of the source.
        """
        ...
    
    def get_queue_source(self) -> Source:
        """Return the ``Source`` to be used as the queue source for a player.

        Default implementation returns ``self`` if this source is precise as
        specified by :meth:`is_precise` or if the ``imprecise_ok`` argument
        is given. Otherwise, a new :class:`PreciseStreamingSource` wrapping
        this source is returned.

        Returns:
            :class:`Source`
        """
        ...
    
    def get_audio_data(self, num_bytes: int, compensation_time=...) -> Optional[AudioData]:
        """Get next packet of audio data.

        Args:
            num_bytes (int): A size hint for the amount of bytes to return,
                but the returned amount may be lower or higher.
            compensation_time (float): Time in sec to compensate due to a
                difference between the master clock and the audio clock.

        .. deprecated:: 2.0.10
            compensation_time: Will always be given as ``0.0``.

        Returns:
            :class:`.AudioData`: Next packet of audio data, or ``None`` if
            there is no (more) data.
        """
        ...
    


class StreamingSource(Source):
    """A source that is decoded as it is being played.

    The source can only be played once at a time on any
    :class:`~pyglet.media.player.Player`.
    """
    def get_queue_source(self) -> StreamingSource:
        """Return the ``Source`` to be used as the source for a player.

        Default implementation returns self.

        Returns:
            :class:`.Source`
        """
        ...
    
    def delete(self) -> None:
        """Release the resources held by this StreamingSource."""
        ...
    


class StaticSource(Source):
    """A source that has been completely decoded in memory.

    This source can be queued onto multiple players any number of times.

    Construct a :py:class:`~pyglet.media.StaticSource` for the data in
    ``source``.

    Args:
        source (Source):  The source to read and decode audio and video data
            from.
    """
    def __init__(self, source: Source) -> None:
        ...
    
    def get_queue_source(self) -> Optional[StaticMemorySource]:
        ...
    
    def get_audio_data(self, num_bytes: float, compensation_time: float = ...) -> Optional[AudioData]:
        """The StaticSource does not provide audio data.

        When the StaticSource is queued on a
        :class:`~pyglet.media.player.Player`, it creates a
        :class:`.StaticMemorySource` containing its internal audio data and
        audio format.

        Raises:
            RuntimeError
        """
        ...
    


class StaticMemorySource(StaticSource):
    """
    Helper class for default implementation of :class:`.StaticSource`.

    Do not use directly. This class is used internally by pyglet.

    Args:
        data (readable buffer): The audio data.
        audio_format (AudioFormat): The audio format.
    """
    def __init__(self, data, audio_format: AudioFormat) -> None:
        """Construct a memory source over the given data buffer."""
        ...
    
    def is_precise(self) -> bool:
        ...
    
    def seek(self, timestamp: float) -> None:
        """Seek to given timestamp.

        Args:
            timestamp (float): Time where to seek in the source.
        """
        ...
    
    def get_audio_data(self, num_bytes: float, compensation_time: float = ...) -> Optional[AudioData]:
        """Get next packet of audio data.

        Args:
            num_bytes (int): Maximum number of bytes of data to return.

        Returns:
            :class:`.AudioData`: Next packet of audio data, or ``None`` if
            there is no (more) data.
        """
        ...
    


class SourceGroup:
    """Group of like sources to allow gapless playback.

    Seamlessly read data from a group of sources to allow for
    gapless playback. All sources must share the same audio format.
    The first source added sets the format.
    """
    def __init__(self) -> None:
        ...
    
    def is_precise(self) -> bool:
        ...
    
    def seek(self, time: float) -> None:
        ...
    
    def add(self, source: Source) -> None:
        ...
    
    def has_next(self) -> bool:
        ...
    
    def get_queue_source(self) -> SourceGroup:
        ...
    
    def get_audio_data(self, num_bytes: float, compensation_time=...) -> Optional[AudioData]:
        """Get next audio packet.

        :Parameters:
            `num_bytes` : int
                Hint for preferred size of audio packet; may be ignored.

        :rtype: `AudioData`
        :return: Audio data, or None if there is no more data.
        """
        ...
    


class PreciseStreamingSource(StreamingSource):
    """Wrap non-precise sources that may over- or undershoot.

    Purpose of this source is to always return data whose length is equal or
    less than in length, where less hints at definite source exhaustion.

    This source is used by pyglet internally, you probably don't need to
    bother with it.

    This source erases AudioData-contained timestamp/duration information and
    events.
    """
    def __init__(self, source: Source) -> None:
        ...
    
    @property
    def is_player_source(self) -> bool:
        ...
    
    @is_player_source.setter
    def is_player_source(self, n: bool) -> None:
        ...
    
    def is_precise(self) -> bool:
        ...
    
    def seek(self, timestamp: float) -> None:
        ...
    
    def get_audio_data(self, num_bytes: int) -> Optional[AudioData]:
        ...
    
    def get_next_video_timestamp(self) -> Optional[float]:
        ...
    
    def get_next_video_frame(self) -> Optional[AbstractImage]:
        ...
    
    def save(self, filename: str, file: Optional[BinaryIO] = ..., encoder: Optional[MediaEncoder] = ...) -> None:
        ...
    
    def delete(self) -> None:
        ...
    


