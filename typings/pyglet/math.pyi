"""
This type stub file was generated by pyright.
"""

import typing as _typing
from collections.abc import Iterable as _Iterable

"""Matrix and Vector math.

This module provides Vector and Matrix objects, including Vec2, Vec3,
Vec4, Mat3, and Mat4. Most common matrix and vector operations are
supported. Helper methods are included for rotating, scaling, and
transforming. The :py:class:`~pyglet.matrix.Mat4` includes class methods
for creating orthographic and perspective projection matrixes.

Matrices behave just like they do in GLSL: they are specified in column-major
order and multiply on the left of vectors, which are treated as columns.

All objects are immutable and hashable.
"""
Mat3T = _typing.TypeVar("Mat3T", bound="Mat3")
Mat4T = _typing.TypeVar("Mat4T", bound="Mat4")
def clamp(num: float, min_val: float, max_val: float) -> float:
    """Clamp a value between a minimum and maximum limit."""
    ...

class Vec2(_typing.NamedTuple):
    """A two-dimensional vector represented as an X Y coordinate pair.

    `Vec2` is an immutable 2D Vector, including most common
    operators. As an immutable type, all operations return a new object.

    .. note:: The Python `len` operator returns the number of elements in
              the vector. For the vector length, use the `abs` operator.
    """
    x: float = ...
    y: float = ...
    def __add__(self, other: Vec2) -> Vec2:
        ...
    
    def __sub__(self, other: Vec2) -> Vec2:
        ...
    
    def __mul__(self, scalar: float) -> Vec2:
        ...
    
    def __truediv__(self, scalar: float) -> Vec2:
        ...
    
    def __floordiv__(self, scalar: float) -> Vec2:
        ...
    
    def __radd__(self, other: _typing.Union[Vec2, int]) -> Vec2:
        ...
    
    __rsub__ = ...
    __rmul__ = ...
    __rtruediv__ = ...
    __rfloordiv__ = ...
    def __abs__(self) -> float:
        ...
    
    def __neg__(self) -> Vec2:
        ...
    
    def __round__(self, ndigits: _typing.Optional[int] = ...) -> Vec2:
        ...
    
    def __lt__(self, other: Vec2) -> bool:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    @staticmethod
    def from_polar(mag: float, angle: float) -> Vec2:
        """Create a new vector from the given polar coordinates.

        Args:
          mag: The desired magnitude.
          angle: The angle, in radians.
        """
        ...
    
    def from_magnitude(self, magnitude: float) -> Vec2:
        """Create a new vector of the given magnitude

        The new vector will be created by first normalizing,
        then scaling the vector. The heading remains unchanged.
        """
        ...
    
    def from_heading(self, heading: float) -> Vec2:
        """Create a new vector of the same magnitude with the given heading.

         In effect, the vector rotated to the new heading.

        Args:
          heading: The desired heading, in radians.

        """
        ...
    
    @property
    def heading(self) -> float:
        """The angle of the vector in radians."""
        ...
    
    @property
    def mag(self) -> float:
        """The magnitude, or length of the vector.

        The distance between the coordinates and the origin.
        Alias of abs(vec2_instance).
        """
        ...
    
    def limit(self, maximum: float) -> Vec2:
        """Limit the magnitude of the vector to passed maximum value."""
        ...
    
    def lerp(self, other: Vec2, alpha: float) -> Vec2:
        """Create a new Vec2 linearly interpolated between this vector and another Vec2.

        Args:
          other: Another Vec2 instance.
          alpha: The amount of interpolation between this vector, and the other
                 vector. This should be a value between 0.0 and 1.0. For example:
                 0.5 is the midway point between both vectors.
        """
        ...
    
    def reflect(self, vector: Vec2) -> Vec2:
        """Create a new Vec2 reflected (ricochet) from the given normalized vector.

        Args:
          vector: A normalized vector.
        """
        ...
    
    def rotate(self, angle: float) -> Vec2:
        """Create a new vector rotated by the angle. The magnitude remains unchanged.

        Args:
          angle: The desired angle, in radians.
        """
        ...
    
    def distance(self, other: Vec2) -> float:
        """Calculate the distance between this vector and another 2D vector."""
        ...
    
    def normalize(self) -> Vec2:
        """Normalize the vector to have a magnitude of 1. i.e. make it a unit vector."""
        ...
    
    def clamp(self, min_val: float, max_val: float) -> Vec2:
        """Restrict the value of the X and Y components of the vector to be within the given values."""
        ...
    
    def dot(self, other: Vec2) -> float:
        """Calculate the dot product of this vector and another 2D vector."""
        ...
    
    def index(self, *args):
        ...
    
    def __getattr__(self, attrs: str) -> _typing.Union[Vec2, Vec3, Vec4]:
        ...
    


class Vec3(_typing.NamedTuple):
    """A three-dimensional vector represented as X Y Z coordinates.

    `Vec3` is an immutable 2D Vector, including most common operators.
    As an immutable type, all operations return a new object.

    .. note:: The Python `len` operator returns the number of elements in
              the vector. For the vector length, use the `abs` operator.
    """
    x: float = ...
    y: float = ...
    z: float = ...
    @property
    def mag(self) -> float:
        """The magnitude, or length of the vector.

        The distance between the coordinates and the origin.
        Alias of abs(vector_instance).
        """
        ...
    
    def __add__(self, other: Vec3) -> Vec3:
        ...
    
    def __sub__(self, other: Vec3) -> Vec3:
        ...
    
    def __mul__(self, scalar: float) -> Vec3:
        ...
    
    def __truediv__(self, scalar: float) -> Vec3:
        ...
    
    def __floordiv__(self, scalar: float) -> Vec3:
        ...
    
    def __radd__(self, other: _typing.Union[Vec3, int]) -> Vec3:
        ...
    
    __rsub__ = ...
    __rmul__ = ...
    __rtruediv__ = ...
    __rfloordiv__ = ...
    def __abs__(self) -> float:
        ...
    
    def __neg__(self) -> Vec3:
        ...
    
    def __round__(self, ndigits: _typing.Optional[int] = ...) -> Vec3:
        ...
    
    def __lt__(self, other: Vec3) -> bool:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    def from_magnitude(self, magnitude: float) -> Vec3:
        """Create a new vector of the given magnitude

        The new vector will be created by first normalizing,
        then scaling the vector. The heading remains unchanged.
        """
        ...
    
    def limit(self, maximum: float) -> Vec3:
        """Limit the magnitude of the vector to passed maximum value."""
        ...
    
    def cross(self, other: Vec3) -> Vec3:
        """Calculate the cross product of this vector and another 3D vector."""
        ...
    
    def dot(self, other: Vec3) -> float:
        """Calculate the dot product of this vector and another 3D vector."""
        ...
    
    def lerp(self, other: Vec3, alpha: float) -> Vec3:
        """Create a new Vec3 linearly interpolated between this vector and another Vec3.

        Args:
          other: Another Vec3 instance.
          alpha: The amount of interpolation between this vector, and the other
                 vector. This should be a value between 0.0 and 1.0. For example:
                 0.5 is the midway point between both vectors.
        """
        ...
    
    def distance(self, other: Vec3) -> float:
        """Get the distance between this vector and another 3D vector."""
        ...
    
    def normalize(self) -> Vec3:
        """Normalize the vector to have a magnitude of 1. i.e. make it a unit vector."""
        ...
    
    def clamp(self, min_val: float, max_val: float) -> Vec3:
        """Restrict the value of the X, Y and Z components of the vector to be within the given values."""
        ...
    
    def index(self, *args):
        ...
    
    def __getattr__(self, attrs: str) -> _typing.Union[Vec2, Vec3, Vec4]:
        ...
    


class Vec4(_typing.NamedTuple):
    """A four-dimensional vector represented as X Y Z W coordinates.

    `Vec3` is an immutable 2D Vector, including most common operators.
    As an immutable type, all operations return a new object.

    .. note:: The Python `len` operator returns the number of elements in
              the vector. For the vector length, use the `abs` operator.
    """
    x: float = ...
    y: float = ...
    z: float = ...
    w: float = ...
    def __add__(self, other: Vec4) -> Vec4:
        ...
    
    def __sub__(self, other: Vec4) -> Vec4:
        ...
    
    def __mul__(self, scalar: float) -> Vec4:
        ...
    
    def __truediv__(self, scalar: float) -> Vec4:
        ...
    
    def __floordiv__(self, scalar: float) -> Vec4:
        ...
    
    def __abs__(self) -> float:
        ...
    
    def __neg__(self) -> Vec4:
        ...
    
    def __round__(self, ndigits: _typing.Optional[int] = ...) -> Vec4:
        ...
    
    def __radd__(self, other: _typing.Union[Vec4, int]) -> Vec4:
        ...
    
    __rsub__ = ...
    __rmul__ = ...
    __rtruediv__ = ...
    __rfloordiv__ = ...
    def __lt__(self, other: Vec4) -> bool:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    def lerp(self, other: Vec4, alpha: float) -> Vec4:
        """Create a new Vec4 linearly interpolated between this vector and another Vec4.

        Args:
          other: Another Vec4 instance.
          alpha: The amount of interpolation between this vector, and the other
                 vector. This should be a value between 0.0 and 1.0. For example:
                 0.5 is the midway point between both vectors.
        """
        ...
    
    def distance(self, other: Vec4) -> float:
        ...
    
    def normalize(self) -> Vec4:
        """Normalize the vector to have a magnitude of 1. i.e. make it a unit vector."""
        ...
    
    def clamp(self, min_val: float, max_val: float) -> Vec4:
        ...
    
    def dot(self, other: Vec4) -> float:
        ...
    
    def index(self, *args):
        ...
    
    def __getattr__(self, attrs: str) -> _typing.Union[Vec2, Vec3, Vec4]:
        ...
    


class Mat3(tuple):
    """A 3x3 Matrix

    `Mat3` is an immutable 3x3 Matrix, wich includes most common operators.

    A Matrix can be created with a list or tuple of 12 values.
    If no values are provided, an "identity matrix" will be created
    (1.0 on the main diagonal). Because Mat3 objects are immutable,
    all operations return a new Mat3 object.

    .. note:: Matrix multiplication is performed using the "@" operator.
    """
    def __new__(cls: type[Mat3T], values: _Iterable[float] = ...) -> Mat3T:
        ...
    
    def scale(self, sx: float, sy: float) -> Mat3:
        ...
    
    def translate(self, tx: float, ty: float) -> Mat3:
        ...
    
    def rotate(self, phi: float) -> Mat3:
        ...
    
    def shear(self, sx: float, sy: float) -> Mat3:
        ...
    
    def __add__(self, other: Mat3) -> Mat3:
        ...
    
    def __sub__(self, other: Mat3) -> Mat3:
        ...
    
    def __pos__(self) -> Mat3:
        ...
    
    def __neg__(self) -> Mat3:
        ...
    
    def __round__(self, ndigits: _typing.Optional[int] = ...) -> Mat3:
        ...
    
    def __mul__(self, other: object) -> _typing.NoReturn:
        ...
    
    @_typing.overload
    def __matmul__(self, other: Vec3) -> Vec3:
        ...
    
    @_typing.overload
    def __matmul__(self, other: Mat3) -> Mat3:
        ...
    
    def __matmul__(self, other): # -> Vec3 | Mat3:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Mat4(tuple):
    """A 4x4 Matrix

    `Mat4` is an immutable 4x4 Matrix, which includs most common operators.
    This includes class methods for creating orthogonal and perspective
    projection matrixes, which can be used directly by OpenGL.

    A Matrix can be created with a list or tuple of 16 values. If no values
    are provided, an "identity matrix" will be created (1.0 on the main diagonal).
    Mat4 objects are immutable, so all operations return a new Mat4 object.

    .. note:: Matrix multiplication is performed using the "@" operator.
    """
    def __new__(cls: type[Mat4T], values: _Iterable[float] = ...) -> Mat4T:
        ...
    
    @classmethod
    def orthogonal_projection(cls: type[Mat4T], left: float, right: float, bottom: float, top: float, z_near: float, z_far: float) -> Mat4T:
        """Create a Mat4 orthographic projection matrix for use with OpenGL.

        Given left, right, bottom, top values, and near/far z planes,
        create a 4x4 Projection Matrix. This is useful for setting
        :py:attr:`~pyglet.window.Window.projection`.
        """
        ...
    
    @classmethod
    def perspective_projection(cls: type[Mat4T], aspect: float, z_near: float, z_far: float, fov: float = ...) -> Mat4T:
        """Create a Mat4 perspective projection matrix for use with OpenGL.

        Given a desired aspect ratio, near/far planes, and fov (field of view),
        create a 4x4 Projection Matrix. This is useful for setting
        :py:attr:`~pyglet.window.Window.projection`.
        """
        ...
    
    @classmethod
    def from_rotation(cls, angle: float, vector: Vec3) -> Mat4:
        """Create a rotation matrix from an angle and Vec3.

        Args:
          angle: The desired angle, in radians.
          vector: A Vec3 indicating the direction.
        """
        ...
    
    @classmethod
    def from_scale(cls: type[Mat4T], vector: Vec3) -> Mat4T:
        """Create a scale matrix from a Vec3."""
        ...
    
    @classmethod
    def from_translation(cls: type[Mat4T], vector: Vec3) -> Mat4T:
        """Create a translation matrix from a Vec3."""
        ...
    
    @classmethod
    def look_at(cls: type[Mat4T], position: Vec3, target: Vec3, up: Vec3): # -> Mat4T:
        """Create a viewing matrix that points toward a target.

        This method takes three Vec3s, describing the viewer's position,
        where they are looking, and the upward axis (typically positive
        on the Y axis). The resulting Mat4 can be used as the projection
        matrix.

        Args:
          position: The location of the viewer in the scene.
          target: The point that the viewer is looking towards.
          up: A vector pointing "up" in the scene, typically `Vec3(0.0, 1.0, 0.0)`.
        """
        ...
    
    def row(self, index: int) -> tuple:
        """Get a specific row as a tuple."""
        ...
    
    def column(self, index: int) -> tuple:
        """Get a specific column as a tuple."""
        ...
    
    def rotate(self, angle: float, vector: Vec3) -> Mat4:
        """Get a rotation Matrix on x, y, or z axis."""
        ...
    
    def scale(self, vector: Vec3) -> Mat4:
        """Get a scale Matrix on x, y, or z axis."""
        ...
    
    def translate(self, vector: Vec3) -> Mat4:
        """Get a translation Matrix along x, y, and z axis."""
        ...
    
    def transpose(self) -> Mat4:
        """Get a transpose of this Matrix."""
        ...
    
    def __add__(self, other: Mat4) -> Mat4:
        ...
    
    def __sub__(self, other: Mat4) -> Mat4:
        ...
    
    def __pos__(self) -> Mat4:
        ...
    
    def __neg__(self) -> Mat4:
        ...
    
    def __invert__(self) -> Mat4:
        ...
    
    def __round__(self, ndigits: _typing.Optional[int] = ...) -> Mat4:
        ...
    
    def __mul__(self, other: int) -> _typing.NoReturn:
        ...
    
    @_typing.overload
    def __matmul__(self, other: Vec4) -> Vec4:
        ...
    
    @_typing.overload
    def __matmul__(self, other: Mat4) -> Mat4:
        ...
    
    def __matmul__(self, other): # -> Vec4 | Mat4:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Quaternion(_typing.NamedTuple):
    """Quaternion"""
    w: float = ...
    x: float = ...
    y: float = ...
    z: float = ...
    @classmethod
    def from_mat3(cls) -> Quaternion:
        ...
    
    @classmethod
    def from_mat4(cls) -> Quaternion:
        ...
    
    def to_mat4(self) -> Mat4:
        ...
    
    def to_mat3(self) -> Mat3:
        ...
    
    @property
    def mag(self) -> float:
        """The magnitude, or length, of the Quaternion.

        The distance between the coordinates and the origin.
        Alias of abs(quaternion_instance).
        """
        ...
    
    def conjugate(self) -> Quaternion:
        ...
    
    def dot(self, other: Quaternion) -> float:
        ...
    
    def normalize(self) -> Quaternion:
        ...
    
    def __abs__(self) -> float:
        ...
    
    def __add__(self, other: Quaternion) -> Quaternion:
        ...
    
    def __sub__(self, other: Quaternion) -> Quaternion:
        ...
    
    def __mul__(self, scalar: float) -> Quaternion:
        ...
    
    def __truediv__(self, other: Quaternion) -> Quaternion:
        ...
    
    def __invert__(self) -> Quaternion:
        ...
    
    def __matmul__(self, other: Quaternion) -> Quaternion:
        ...
    


