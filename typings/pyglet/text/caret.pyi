"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional, Pattern, TYPE_CHECKING, Tuple
from pyglet.text.layout import IncrementalTextLayout
from pyglet.graphics import Batch

"""Provides keyboard and mouse editing procedures for text layout.

Example usage::

    from pyglet import window
    from pyglet.text import layout, caret

    my_window = window.Window(...)
    my_layout = layout.IncrementalTextLayout(...)
    my_caret = caret.Caret(my_layout)
    my_window.push_handlers(my_caret)

.. versionadded:: 1.1
"""
if TYPE_CHECKING:
    ...
class Caret:
    """Visible text insertion marker for
    `pyglet.text.layout.IncrementalTextLayout`.

    The caret is drawn as a single vertical bar at the document `position` 
    on a text layout object.  If `mark` is not None, it gives the unmoving
    end of the current text selection.  The visible text selection on the
    layout is updated along with `mark` and `position`.
    
    By default the layout's graphics batch is used, so the caret does not need
    to be drawn explicitly.  Even if a different graphics batch is supplied,
    the caret will be correctly positioned and clipped within the layout.

    Updates to the document (and so the layout) are automatically propagated
    to the caret.  

    The caret object can be pushed onto a window event handler stack with
    `Window.push_handlers`.  The caret will respond correctly to keyboard,
    text, mouse and activation events, including double- and triple-clicks.
    If the text layout is being used alongside other graphical widgets, a
    GUI toolkit will be needed to delegate keyboard and mouse events to the
    appropriate widget.  pyglet does not provide such a toolkit at this stage.
    """
    _next_word_re: Pattern[str] = ...
    _previous_word_re: Pattern[str] = ...
    _next_para_re: Pattern[str] = ...
    _previous_para_re: Pattern[str] = ...
    _position: int = ...
    _active: bool = ...
    _visible: bool = ...
    _blink_visible: bool = ...
    _click_count: int = ...
    _click_time: float = ...
    PERIOD: float = ...
    SCROLL_INCREMENT: int = ...
    _mark: Optional[int] = ...
    _next_attributes: dict[str, Any]
    def __init__(self, layout: IncrementalTextLayout, batch: Batch = ..., color: Tuple[int, int, int, int] = ...) -> None:
        """Create a caret for a layout.

        By default the layout's batch is used, so the caret does not need to
        be drawn explicitly.

        :Parameters:
            `layout` : `~pyglet.text.layout.IncrementalTextLayout`
                Layout to control.
            `batch` : `~pyglet.graphics.Batch`
                Graphics batch to add vertices to.
            `color` : (int, int, int, int)
                An RGBA or RGB tuple with components in the range [0, 255].
                RGB colors will be treated as having an opacity of 255.

        """
        ...
    
    @property
    def layout(self) -> IncrementalTextLayout:
        ...
    
    @layout.setter
    def layout(self, layout: IncrementalTextLayout) -> None:
        ...
    
    def delete(self) -> None:
        """Remove the caret from its batch.

        Also disconnects the caret from further layout events.
        """
        ...
    
    @property
    def visible(self) -> bool:
        """Caret visibility.

        The caret may be hidden despite this property due to the periodic blinking
        or by `on_deactivate` if the event handler is attached to a window.

        :type: bool
        """
        ...
    
    @visible.setter
    def visible(self, visible: bool) -> None:
        ...
    
    @property
    def color(self) -> Tuple[int, int, int, int]:
        """An RGBA tuple of the current caret color

        When blinking off, the alpha channel will be set to ``0``.  The
        default caret color when visible is ``(0, 0, 0, 255)`` (opaque black).

        You may set the color to an RGBA or RGB color tuple.

        .. warning:: This setter can fail for a short time after layout / window init!

                     Use ``__init__``'s ``color`` keyword argument instead if you
                     run into this problem.

        Each color channel must be between 0 and 255, inclusive. If the color
        set to an RGB color, the previous alpha channel value will be used.

        :type: (int, int, int, int)
        """
        ...
    
    @color.setter
    def color(self, color: Tuple[int, int, int, int] | Tuple[int, int, int]) -> None:
        ...
    
    @property
    def position(self) -> int:
        """Position of caret within document."""
        ...
    
    @position.setter
    def position(self, position: int) -> None:
        ...
    
    @property
    def mark(self) -> int:
        """Position of immovable end of text selection within document.

        An interactive text selection is determined by its immovable end (the
        caret's position when a mouse drag begins) and the caret's position, which
        moves interactively by mouse and keyboard input.

        This property is ``None`` when there is no selection.

        :type: int
        """
        ...
    
    @mark.setter
    def mark(self, mark: int) -> None:
        ...
    
    @property
    def line(self) -> int:
        """Index of line containing the caret's position.

        When set, `position` is modified to place the caret on requested line
        while maintaining the closest possible X offset.

        :rtype: int
        """
        ...
    
    @line.setter
    def line(self, line: int) -> None:
        ...
    
    def get_style(self, attribute: str) -> Any:
        """Get the document's named style at the caret's current position.

        If there is a text selection and the style varies over the selection,
        `pyglet.text.document.STYLE_INDETERMINATE` is returned.

        :Parameters:
            `attribute` : str
                Name of style attribute to retrieve.  See
                `pyglet.text.document` for a list of recognised attribute
                names.

        :rtype: object
        """
        ...
    
    def set_style(self, attributes: dict[str, Any]) -> None:
        """Set the document style at the caret's current position.

        If there is a text selection the style is modified immediately.
        Otherwise, the next text that is entered before the position is
        modified will take on the given style.

        :Parameters:
            `attributes` : dict
                Dict mapping attribute names to style values.  See
                `pyglet.text.document` for a list of recognised attribute
                names.

        """
        ...
    
    def move_to_point(self, x: int, y: int) -> None:
        """Move the caret close to the given window coordinate.

        The `mark` will be reset to ``None``.

        :Parameters:
            `x` : int   
                X coordinate.
            `y` : int
                Y coordinate.

        """
        ...
    
    def select_to_point(self, x: int, y: int) -> None:
        """Move the caret close to the given window coordinate while
        maintaining the `mark`.

        :Parameters:
            `x` : int   
                X coordinate.
            `y` : int
                Y coordinate.

        """
        ...
    
    def select_all(self) -> None:
        """Select all text in the document."""
        ...
    
    def select_word(self, x: int, y: int) -> None:
        """Select the word at the given window coordinate.

        :Parameters:
            `x` : int   
                X coordinate.
            `y` : int
                Y coordinate.

        """
        ...
    
    def select_paragraph(self, x: int, y: int) -> None:
        """Select the paragraph at the given window coordinate.

        :Parameters:
            `x` : int   
                X coordinate.
            `y` : int
                Y coordinate.

        """
        ...
    
    def on_translation_update(self) -> None:
        ...
    
    def on_layout_update(self) -> None:
        """Handler for the `IncrementalTextLayout.on_layout_update` event.
        """
        ...
    
    def on_text(self, text: str) -> bool:
        """Handler for the `pyglet.window.Window.on_text` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        """
        ...
    
    def on_text_motion(self, motion: int, select: bool = ...) -> bool:
        """Handler for the `pyglet.window.Window.on_text_motion` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        """
        ...
    
    def on_text_motion_select(self, motion: int) -> bool:
        """Handler for the `pyglet.window.Window.on_text_motion_select` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        """
        ...
    
    def on_mouse_scroll(self, x: float, y: float, scroll_x: float, scroll_y: float) -> bool:
        """Handler for the `pyglet.window.Window.on_mouse_scroll` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.

        The layout viewport is scrolled by `SCROLL_INCREMENT` pixels per
        "click".
        """
        ...
    
    def on_mouse_press(self, x: int, y: int, button: int, modifiers: int) -> bool:
        """Handler for the `pyglet.window.Window.on_mouse_press` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.

        This handler keeps track of the number of mouse presses within
        a short span of time and uses this to reconstruct double- and
        triple-click events for selecting words and paragraphs.  This
        technique is not suitable when a GUI toolkit is in use, as the active
        widget must also be tracked.  Do not use this mouse handler if
        a GUI toolkit is being used.
        """
        ...
    
    def on_mouse_drag(self, x: int, y: int, dx: int, dy: int, buttons: int, modifiers: int) -> bool:
        """Handler for the `pyglet.window.Window.on_mouse_drag` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.
        """
        ...
    
    def on_activate(self) -> bool:
        """Handler for the `pyglet.window.Window.on_activate` event.

        The caret is hidden when the window is not active.
        """
        ...
    
    def on_deactivate(self) -> bool:
        """Handler for the `pyglet.window.Window.on_deactivate` event.

        The caret is hidden when the window is not active.
        """
        ...
    


