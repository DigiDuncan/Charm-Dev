"""
This type stub file was generated by pyright.
"""

from typing import Optional, TYPE_CHECKING, Tuple, Type
from pyglet import graphics
from pyglet.customtypes import AnchorX, AnchorY
from pyglet.text.layout.base import TextLayout
from pyglet.graphics import Batch
from pyglet.graphics.shader import ShaderProgram
from pyglet.text.document import AbstractDocument
from pyglet.image import Texture

if TYPE_CHECKING:
    ...
class ScrollableTextLayoutGroup(graphics.Group):
    scissor_area = ...
    def __init__(self, texture: Texture, program: ShaderProgram, order: int = ..., parent: Optional[graphics.Group] = ...) -> None:
        """Default rendering group for :py:class:`~pyglet.text.layout.ScrollableTextLayout`.

        The group maintains internal state for specifying the viewable
        area, and for scrolling. Because the group has internal state
        specific to the text layout, the group is never shared.
        """
        ...
    
    def set_state(self) -> None:
        ...
    
    def unset_state(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: graphics.Group) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class ScrollableTextDecorationGroup(graphics.Group):
    scissor_area = ...
    def __init__(self, program: ShaderProgram, order: int = ..., parent: Optional[graphics.Group] = ...) -> None:
        """Create a text decoration rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self) -> None:
        ...
    
    def unset_state(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: graphics.Group) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class ScrollableTextLayout(TextLayout):
    """Display text in a scrollable viewport.

    This class does not display a scrollbar or handle scroll events; it merely
    clips the text that would be drawn in :py:func:`~pyglet.text.layout.TextLayout`
    to the bounds of the layout given by `x`, `y`, `width` and `height`;
    and offsets the text by a scroll offset.

    Use `view_x` and `view_y` to scroll the text within the viewport.
    """
    group_class: Type[ScrollableTextLayoutGroup] = ...
    decoration_class: Type[ScrollableTextDecorationGroup] = ...
    _translate_x: int = ...
    _translate_y: int = ...
    def __init__(self, document: AbstractDocument, x: float = ..., y: float = ..., z: float = ..., width: int = ..., height: int = ..., anchor_x: AnchorX = ..., anchor_y: AnchorY = ..., rotation: float = ..., multiline: bool = ..., dpi: Optional[float] = ..., batch: Optional[Batch] = ..., group: Optional[graphics.Group] = ..., program: Optional[ShaderProgram] = ..., wrap_lines: bool = ...) -> None:
        ...
    
    @property
    def x(self) -> float:
        ...
    
    @x.setter
    def x(self, x: float) -> None:
        ...
    
    @property
    def y(self) -> float:
        ...
    
    @y.setter
    def y(self, y: float) -> None:
        ...
    
    @property
    def z(self) -> float:
        ...
    
    @z.setter
    def z(self, z: float) -> None:
        ...
    
    @property
    def position(self) -> Tuple[float, float, float]:
        ...
    
    @position.setter
    def position(self, position: Tuple[float, float, float]) -> None:
        ...
    
    @property
    def anchor_x(self) -> AnchorX:
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x: AnchorX) -> None:
        ...
    
    @property
    def anchor_y(self) -> AnchorY:
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y: AnchorY) -> None:
        ...
    
    @property
    def view_x(self) -> int:
        """Horizontal scroll offset.

            The initial value is 0, and the left edge of the text will touch the left
            side of the layout bounds.  A positive value causes the text to "scroll"
            to the right.  Values are automatically clipped into the range
            ``[0, content_width - width]``

            :type: int
        """
        ...
    
    @view_x.setter
    def view_x(self, view_x: int) -> None:
        ...
    
    @property
    def view_y(self) -> int:
        """Vertical scroll offset.

            The initial value is 0, and the top of the text will touch the top of the
            layout bounds (unless the content height is less than the layout height,
            in which case `content_valign` is used).

            A negative value causes the text to "scroll" upwards.  Values outside of
            the range ``[height - content_height, 0]`` are automatically clipped in
            range.

            :type: int
        """
        ...
    
    @view_y.setter
    def view_y(self, view_y: int) -> None:
        ...
    


