"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Pattern, Protocol, TYPE_CHECKING, Tuple, Type, Union
from pyglet import graphics
from pyglet.customtypes import AnchorX, AnchorY, ContentVAlign, HorizontalAlign
from pyglet.font.base import Font, Glyph
from pyglet.image import Texture
from pyglet.text.runlist import AbstractRunIterator, RunIterator
from pyglet.graphics.shader import ShaderProgram
from pyglet.graphics.vertexdomain import VertexList
from pyglet.graphics import Batch
from pyglet.text.document import AbstractDocument, InlineElement

if TYPE_CHECKING:
    ...
_is_pyglet_doc_run = ...
layout_vertex_source = ...
layout_fragment_source = ...
layout_fragment_image_source = ...
decoration_vertex_source = ...
decoration_fragment_source = ...
class _LayoutVertexList(Protocol):
    """Just a Protocol to add completion for VertexLists."""
    position: List
    colors: List
    translation: List
    view_translation: List
    anchor: List
    rotation: List
    visible: List
    count: int
    def delete(self) -> None:
        ...
    


def get_default_layout_shader() -> ShaderProgram:
    ...

def get_default_image_layout_shader() -> ShaderProgram:
    ...

def get_default_decoration_shader() -> ShaderProgram:
    ...

_distance_re: Pattern[str] = ...
class _Line:
    boxes: List[_AbstractBox]
    vertex_lists: List[VertexList]
    start: int
    align: HorizontalAlign = ...
    margin_left: int = ...
    margin_right: int = ...
    length: int = ...
    ascent: float = ...
    descent: float = ...
    width: float = ...
    paragraph_begin: bool = ...
    paragraph_end: bool = ...
    x: int
    y: int
    def __init__(self, start: int) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def add_box(self, box: _AbstractBox) -> None:
        ...
    
    def delete(self, layout: TextLayout) -> None:
        ...
    


class _LayoutContext:
    def __init__(self, layout: TextLayout, document: AbstractDocument, colors_iter: RunIterator, background_iter: AbstractRunIterator) -> None:
        ...
    
    def add_list(self, vertex_list: VertexList):
        ...
    
    def add_box(self, box: _AbstractBox):
        ...
    


class _StaticLayoutContext(_LayoutContext):
    def __init__(self, layout: TextLayout, document: AbstractDocument, colors_iter: RunIterator, background_iter: AbstractRunIterator) -> None:
        ...
    
    def add_list(self, vertex_list: _LayoutVertexList): # -> None:
        ...
    


class _AbstractBox(ABC):
    """A box has two cases, A GlyphBox and an InlineElementBox
    """
    owner: Optional[Texture]
    ascent: float
    descent: float
    advance: float
    length: int
    def __init__(self, ascent: float, descent: float, advance: float, length: int) -> None:
        ...
    
    @abstractmethod
    def place(self, layout: TextLayout, i: int, x: float, y: float, z: float, line_x: float, line_y: float, rotation: float, visible: bool, anchor_x: float, anchor_y: float, context: _LayoutContext) -> None:
        ...
    
    @abstractmethod
    def update_translation(self, x: float, y: float, z: float) -> None:
        ...
    
    @abstractmethod
    def update_colors(self, colors: List[int]) -> None:
        ...
    
    @abstractmethod
    def update_view_translation(self, translate_x: float, translate_y: float) -> None:
        ...
    
    @abstractmethod
    def update_rotation(self, rotation: float) -> None:
        ...
    
    @abstractmethod
    def update_visibility(self, visible: bool) -> None:
        ...
    
    @abstractmethod
    def update_anchor(self, anchor_x: float, anchor_y: float) -> None:
        ...
    
    @abstractmethod
    def delete(self, layout: TextLayout) -> None:
        ...
    
    @abstractmethod
    def get_position_in_box(self, x: int) -> int:
        ...
    
    @abstractmethod
    def get_point_in_box(self, position: int) -> float:
        ...
    


class _GlyphBox(_AbstractBox):
    owner: Texture
    font: Font
    glyphs: List[Tuple[int, Glyph]]
    advance: int
    vertex_lists: List[_LayoutVertexList]
    def __init__(self, owner: Texture, font: Font, glyphs: List[Tuple[int, Glyph]], advance: int) -> None:
        """Create a run of glyphs sharing the same texture.

        :Parameters:
            `owner` : `pyglet.image.Texture`
                Texture of all glyphs in this run.
            `font` : `pyglet.font.base.Font`
                Font of all glyphs in this run.
            `glyphs` : list of (int, `pyglet.font.base.Glyph`)
                Pairs of ``(kern, glyph)``, where ``kern`` gives horizontal
                displacement of the glyph in pixels (typically 0).
            `advance` : int
                Width of glyph run; must correspond to the sum of advances
                and kerns in the glyph list.

        """
        ...
    
    def place(self, layout: TextLayout, i: int, x: float, y: float, z: float, line_x: float, line_y: float, rotation: float, visible: bool, anchor_x: float, anchor_y: float, context: _LayoutContext) -> None:
        ...
    
    def update_translation(self, x: float, y: float, z: float) -> None:
        ...
    
    def update_colors(self, colors: List[int]) -> None:
        ...
    
    def update_view_translation(self, translate_x: float, translate_y: float) -> None:
        ...
    
    def update_rotation(self, rotation: float) -> None:
        ...
    
    def update_visibility(self, visible: bool) -> None:
        ...
    
    def update_anchor(self, anchor_x: float, anchor_y: float) -> None:
        ...
    
    def delete(self, layout: TextLayout) -> None:
        ...
    
    def get_point_in_box(self, position: int) -> int:
        ...
    
    def get_position_in_box(self, x: int) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class _InlineElementBox(_AbstractBox):
    element: InlineElement
    placed: bool
    def __init__(self, element: InlineElement) -> None:
        """Create a glyph run holding a single element."""
        ...
    
    def place(self, layout: TextLayout, i: int, x: float, y: float, z: float, line_x: float, line_y: float, rotation: float, visible: bool, anchor_x: float, anchor_y: float, context: _LayoutContext) -> None:
        ...
    
    def update_translation(self, x: float, y: float, z: float) -> None:
        ...
    
    def update_colors(self, colors: List[int]) -> None:
        ...
    
    def update_view_translation(self, translate_x: float, translate_y: float) -> None:
        ...
    
    def update_rotation(self, rotation: float) -> None:
        ...
    
    def update_visibility(self, visible: bool) -> None:
        ...
    
    def update_anchor(self, anchor_x: float, anchor_y: float) -> None:
        ...
    
    def delete(self, layout: TextLayout) -> None:
        ...
    
    def get_point_in_box(self, position: int) -> float:
        ...
    
    def get_position_in_box(self, x: int) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class _InvalidRange:
    start: int
    end: int
    def __init__(self) -> None:
        ...
    
    def insert(self, start: int, length: int) -> None:
        ...
    
    def delete(self, start: int, end: int) -> None:
        ...
    
    def invalidate(self, start: int, end: int) -> None:
        ...
    
    def validate(self) -> Tuple[int, int]:
        ...
    
    def is_invalid(self) -> bool:
        ...
    


class TextLayoutGroup(graphics.Group):
    def __init__(self, texture: Texture, program: ShaderProgram, order: int = ..., parent: Optional[graphics.Group] = ...) -> None:
        """Create a text layout rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self) -> None:
        ...
    
    def unset_state(self) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: graphics.Group) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class TextDecorationGroup(graphics.Group):
    def __init__(self, program: ShaderProgram, order: int = ..., parent: Optional[graphics.Group] = ...) -> None:
        """Create a text decoration rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self) -> None:
        ...
    
    def unset_state(self) -> None:
        ...
    


class TextLayout:
    """Lay out and display documents.

    This class is intended for displaying documents that do not change
    regularly -- any change will cost some time to lay out the complete
    document again and regenerate all vertex lists.

    The benefit of this class is that texture state is shared between
    all layouts of this class.  The time to draw one :py:func:`~pyglet.text.layout.TextLayout` may be
    roughly the same as the time to draw one :py:class:`~pyglet.text.layout.IncrementalTextLayout`; but
    drawing ten :py:func:`~pyglet.text.layout.TextLayout` objects in one batch is much faster than drawing
    ten incremental or scrollable text layouts.

    :py:func:`~pyglet.text.Label` and :py:func:`~pyglet.text.HTMLLabel` provide a convenient interface to this class.

    :Ivariables:
        `content_width` : int
            Calculated width of the text in the layout.  This may overflow
            the desired width if word-wrapping failed.
        `content_height` : int
            Calculated height of the text in the layout.
        `group_class` : `~pyglet.graphics.Group`
            Top-level rendering group.
        `background_decoration_group` : `~pyglet.graphics.Group`
            Rendering group for background color.
        `foreground_decoration_group` : `~pyglet.graphics.Group`
            Rendering group for glyph underlines.

    """
    _vertex_lists: List[_LayoutVertexList]
    _boxes: List[_AbstractBox]
    group_cache: Dict[Texture, graphics.Group]
    _document: Optional[AbstractDocument] = ...
    _update_enabled: bool = ...
    _own_batch: bool = ...
    group_class: Type[TextLayoutGroup] = ...
    decoration_class: Type[TextDecorationGroup] = ...
    _ascent: float = ...
    _descent: float = ...
    _line_count: int = ...
    _anchor_left: float = ...
    _anchor_bottom: float = ...
    _x: float
    _y: float
    _z: float
    _rotation: float = ...
    _width: Optional[int] = ...
    _height: Optional[int] = ...
    _anchor_x: AnchorX = ...
    _anchor_y: AnchorY = ...
    _content_valign: ContentVAlign = ...
    _multiline: bool = ...
    _visible: bool = ...
    def __init__(self, document: AbstractDocument, x: float = ..., y: float = ..., z: float = ..., width: Optional[int] = ..., height: Optional[int] = ..., anchor_x: AnchorX = ..., anchor_y: AnchorY = ..., rotation: float = ..., multiline: bool = ..., dpi: Optional[float] = ..., batch: Batch = ..., group: Optional[graphics.Group] = ..., program: Optional[ShaderProgram] = ..., wrap_lines: bool = ..., init_document: bool = ...) -> None:
        """Create a text layout.

        :Parameters:
            `document` : `AbstractDocument`
                Document to display.
            `x` : int
                X coordinate of the label.
            `y` : int
                Y coordinate of the label.
            `z` : int
                Z coordinate of the label.
            `width` : int
                Width of the layout in pixels, or None
            `height` : int
                Height of the layout in pixels, or None
            `anchor_x` : str
                Anchor point of the X coordinate: one of ``"left"``,
                ``"center"`` or ``"right"``.
            `anchor_y` : str
                Anchor point of the Y coordinate: one of ``"bottom"``,
                ``"baseline"``, ``"center"`` or ``"top"``.
            `rotation`: float
                The amount to rotate the label in degrees. A positive amount
                will be a clockwise rotation, negative values will result in
                counter-clockwise rotation.
            `multiline` : bool
                If False, newline and paragraph characters are ignored, and
                text is not word-wrapped.
                If True, text is wrapped only if the `wrap_lines` is True.
            `dpi` : float
                Font resolution; defaults to 96.
            `batch` : `~pyglet.graphics.Batch`
                Optional graphics batch to add this layout to.
            `group` : `~pyglet.graphics.Group`
                Optional Group to parent all internal Groups that this text
                layout uses.  Note that layouts with the same Groups will
                be rendered simultaneously in a Batch.
            `program` : `~pyglet.graphics.shader.ShaderProgram`
                Optional graphics shader to use. Will affect all glyphs.
            `wrap_lines` : bool
                If True and `multiline` is True, the text is word-wrapped using
                the specified width.
            `init_document` : bool
                If True the document will be initialized. If subclassing then
                you may want to avoid duplicate initializations by changing
                to False.
        """
        ...
    
    @property
    def group(self) -> Optional[graphics.Group]:
        ...
    
    @group.setter
    def group(self, group: graphics.Group) -> None:
        ...
    
    @property
    def dpi(self) -> float:
        """Get DPI used by this layout.

        :type: float
        """
        ...
    
    @property
    def document(self) -> AbstractDocument:
        """Document to display.

         For :py:class:`~pyglet.text.layout.IncrementalTextLayout` it is
         far more efficient to modify a document in-place than to replace
         the document instance on the layout.

         :type: `AbstractDocument`
         """
        ...
    
    @document.setter
    def document(self, document: AbstractDocument) -> None:
        ...
    
    @property
    def batch(self) -> Batch:
        """The Batch that this Layout is assigned to.

        If no Batch is assigned, an internal Batch is
        created and used.

        :type: :py:class:`~pyglet.graphics.Batch`

        """
        ...
    
    @batch.setter
    def batch(self, batch: Optional[Batch]) -> None:
        ...
    
    @property
    def program(self) -> ShaderProgram:
        """The ShaderProgram that is assigned to this Layout.

        If set, this shader will impact all text layouts except InlineElements.

        :type: :py:class:`~pyglet.graphics.shader.ShaderProgram`

        """
        ...
    
    @program.setter
    def program(self, shader_program: ShaderProgram) -> None:
        ...
    
    @property
    def x(self) -> float:
        """X coordinate of the layout.

        See also :py:attr:`~pyglet.text.layout.TextLayout.anchor_x`.

        :type: int
        """
        ...
    
    @x.setter
    def x(self, x: float) -> None:
        ...
    
    @property
    def y(self) -> float:
        """Y coordinate of the layout.

        See also `anchor_y`.

        :type: int
        """
        ...
    
    @y.setter
    def y(self, y: float) -> None:
        ...
    
    @property
    def z(self) -> float:
        """Z coordinate of the layout.

        :type: int
        """
        ...
    
    @z.setter
    def z(self, z: float) -> None:
        ...
    
    @property
    def rotation(self) -> float:
        """Rotation of the layout.

        :type: float
        """
        ...
    
    @rotation.setter
    def rotation(self, rotation: float) -> None:
        ...
    
    @property
    def position(self) -> Tuple[float, float, float]:
        """The (X, Y, Z) coordinates of the layout, as a tuple.

        See also :py:attr:`~pyglet.text.layout.TextLayout.anchor_x`,
        and :py:attr:`~pyglet.text.layout.TextLayout.anchor_y`.

        :type: (int, int, int)
        """
        ...
    
    @position.setter
    def position(self, position: Tuple[float, float, float]) -> None:
        ...
    
    @property
    def visible(self) -> bool:
        """True if the layout will be visible when drawn.

        :type: bool
        """
        ...
    
    @visible.setter
    def visible(self, value: bool) -> None:
        ...
    
    @property
    def content_width(self) -> int:
        """Calculated width of the text in the layout.

        This is the actual width of the text in pixels, not the
        user defined :py:attr:`~ppyglet.text.layout.TextLayout.width`.
        The content width may overflow the layout width if word-wrapping
        is not possible.
        """
        ...
    
    @property
    def content_height(self) -> int:
        """The calculated height of the text in the layout.

        This is the actual height of the text in pixels, not the
        user defined :py:attr:`~ppyglet.text.layout.TextLayout.height`.
        """
        ...
    
    @property
    def width(self) -> Optional[int]:
        """The defined maximum width of the layout in pixels, or None

        If `multiline` and `wrap_lines` is True, the `width` defines where the
        text will be wrapped. If `multiline` is False or `wrap_lines` is False,
        this property has no effect.

        :type: int
        """
        ...
    
    @width.setter
    def width(self, width: Optional[int]) -> None:
        ...
    
    @property
    def height(self) -> Optional[int]:
        """The defined maximum height of the layout in pixels, or None

        When `height` is not None, it affects the positioning of the
        text when :py:attr:`~pyglet.text.layout.TextLayout.anchor_y` and
        :py:attr:`~pyglet.text.layout.TextLayout.content_valign` are
        used.

        :type: int
        """
        ...
    
    @height.setter
    def height(self, height: Optional[int]) -> None:
        ...
    
    @property
    def multiline(self) -> bool:
        """Set if multiline layout is enabled.

        If multiline is False, newline and paragraph characters are ignored and
        text is not word-wrapped.
        If True, the text is word-wrapped only if the `wrap_lines` is True.

        :type: bool
        """
        ...
    
    @multiline.setter
    def multiline(self, multiline: bool) -> None:
        ...
    
    @property
    def anchor_x(self) -> AnchorX:
        """Horizontal anchor alignment.

        This property determines the meaning of the `x` coordinate.
        It is one of the enumerants:

        ``"left"`` (default)
            The X coordinate gives the position of the left edge of the layout.
        ``"center"``
            The X coordinate gives the position of the center of the layout.
        ``"right"``
            The X coordinate gives the position of the right edge of the layout.

        For the purposes of calculating the position resulting from this
        alignment, the width of the layout is taken to be `width` if `multiline`
        is True and `wrap_lines` is True, otherwise `content_width`.

        :type: str
        """
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x: AnchorX) -> None:
        ...
    
    @property
    def anchor_y(self) -> AnchorY:
        """Vertical anchor alignment.

        This property determines the meaning of the `y` coordinate.
        It is one of the enumerants:

        ``"top"``
            The Y coordinate gives the position of the top edge of the layout.
        ``"center"``
            The Y coordinate gives the position of the center of the layout.
        ``"baseline"``
            The Y coordinate gives the position of the baseline of the first
            line of text in the layout.
        ``"bottom"`` (default)
            The Y coordinate gives the position of the bottom edge of the layout.

        For the purposes of calculating the position resulting from this
        alignment, the height of the layout is taken to be the smallest of
        `height` and `content_height`.

        See also `content_valign`.

        :type: str
        """
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y: AnchorY) -> None:
        ...
    
    @property
    def content_valign(self) -> ContentVAlign:
        """Vertical alignment of content within larger layout box.

        This property determines how content is positioned within the layout
        box when ``content_height`` is less than ``height``.  It is one
        of the enumerants:

        ``top`` (default)
            Content is aligned to the top of the layout box.
        ``center``
            Content is centered vertically within the layout box.
        ``bottom``
            Content is aligned to the bottom of the layout box.

        This property has no effect when ``content_height`` is greater
        than ``height`` (in which case the content is aligned to the top) or when
        ``height`` is ``None`` (in which case there is no vertical layout box
        dimension).

        :type: str
        """
        ...
    
    @content_valign.setter
    def content_valign(self, content_valign: ContentVAlign) -> None:
        ...
    
    @property
    def left(self) -> float:
        """
        The x-coordinate of the left side of the layout.

        :type: int
        """
        ...
    
    @property
    def right(self) -> float:
        """
        The x-coordinate of the right side of the layout.

        :type: int
        """
        ...
    
    @property
    def bottom(self) -> float:
        """
        The y-coordinate of the bottom side of the layout.

        :type: int
        """
        ...
    
    @property
    def top(self) -> float:
        """
        The y-coordinate of the top side of the layout.

        :type: int
        """
        ...
    
    def parse_distance(self, distance: Optional[Union[str, int, float]]) -> Optional[int]:
        ...
    
    def begin_update(self) -> None:
        """Indicate that a number of changes to the layout or document
        are about to occur.

        Changes to the layout or document between calls to `begin_update` and
        `end_update` do not trigger any costly relayout of text.  Relayout of
        all changes is performed when `end_update` is called.

        Note that between the `begin_update` and `end_update` calls, values
        such as `content_width` and `content_height` are undefined (i.e., they
        may or may not be updated to reflect the latest changes).
        """
        ...
    
    def end_update(self) -> None:
        """Perform pending layout changes since `begin_update`.

        See `begin_update`.
        """
        ...
    
    @property
    def dpi(self): # -> float | int:
        """Get DPI used by this layout.

            Read-only.

            :type: float
        """
        ...
    
    @dpi.setter
    def dpi(self, value): # -> None:
        ...
    
    def delete(self) -> None:
        """Remove this layout from its batch.
        """
        ...
    
    def get_as_texture(self, min_filter=..., mag_filter=...) -> Texture:
        """Returns a Texture with the TextLayout drawn to it. Each call to this function returns a new
        Texture.
        ~Warning: Usage is recommended only if you understand how texture generation affects your application.
        """
        ...
    
    def draw(self) -> None:
        """Draw this text layout.

        Note that this method performs very badly if a batch was supplied to
        the constructor.  If you add this layout to a batch, you should
        ideally use only the batch's draw method.

        If this is not its own batch, InlineElements will not be drawn.
        """
        ...
    
    def on_insert_text(self, start: int, text: str) -> None:
        """Event handler for `AbstractDocument.on_insert_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    
    def on_delete_text(self, start: int, end: int) -> None:
        """Event handler for `AbstractDocument.on_delete_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    
    def on_style_text(self, start: int, end: int, attributes: dict[str, Any]) -> None:
        """Event handler for `AbstractDocument.on_style_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    


