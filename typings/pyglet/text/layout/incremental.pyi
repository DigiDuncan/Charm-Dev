"""
This type stub file was generated by pyright.
"""

from typing import Any, List, Optional, TYPE_CHECKING, Tuple, Type
from pyglet.customtypes import AnchorX, AnchorY
from pyglet.event import EventDispatcher
from pyglet.text import runlist
from pyglet.text.document import AbstractDocument
from pyglet.text.layout.base import TextLayout, _InvalidRange, _LayoutContext, _Line, _is_pyglet_doc_run
from pyglet.text.layout.scrolling import ScrollableTextDecorationGroup, ScrollableTextLayoutGroup
from pyglet.graphics import Batch, Group
from pyglet.graphics.shader import ShaderProgram

if TYPE_CHECKING:
    ...
class _IncrementalLayoutContext(_LayoutContext):
    line = ...
    def add_list(self, vertex_list): # -> None:
        ...
    
    def add_box(self, box): # -> None:
        ...
    


class IncrementalTextLayoutGroup(ScrollableTextLayoutGroup):
    scissor_area = ...


class IncrementalTextDecorationGroup(ScrollableTextDecorationGroup):
    scissor_area = ...


class IncrementalTextLayout(TextLayout, EventDispatcher):
    """Displayed text suitable for interactive editing and/or scrolling
    large documents.

    Unlike :py:func:`~pyglet.text.layout.TextLayout` and
    :py:class:`~pyglet.text.layout.ScrollableTextLayout`, this class generates
    vertex lists only for lines of text that are visible.  As the document is
    scrolled, vertex lists are deleted and created as appropriate to keep
    video memory usage to a minimum and improve rendering speed.

    Changes to the document are quickly reflected in this layout, as only the
    affected line(s) are reflowed.  Use `begin_update` and `end_update` to
    further reduce the amount of processing required.

    The layout can also display a text selection (text with a different
    background color).  The :py:class:`~pyglet.text.caret.Caret` class implements
    a visible text cursor and provides event handlers for scrolling, selecting and
    editing text in an incremental text layout.
    """
    glyphs: List[Any]
    lines: List[_Line]
    _selection_start: int = ...
    _selection_end: int = ...
    _selection_color: Tuple[int, int, int, int] = ...
    _selection_background_color: Tuple[int, int, int, int] = ...
    group_class: Type[IncrementalTextLayoutGroup] = ...
    decoration_class: Type[IncrementalTextDecorationGroup] = ...
    _translate_x: int = ...
    _translate_y: int = ...
    invalid_glyphs: _InvalidRange
    invalid_flow: _InvalidRange
    invalid_lines: _InvalidRange
    invalid_style: _InvalidRange
    invalid_vertex_lines: _InvalidRange
    visible_lines: _InvalidRange
    owner_runs: runlist.RunList
    _width: int
    _height: int
    def __init__(self, document: AbstractDocument, x: float = ..., y: float = ..., z: float = ..., width: int = ..., height: int = ..., anchor_x: AnchorX = ..., anchor_y: AnchorY = ..., rotation: float = ..., multiline: bool = ..., dpi: Optional[float] = ..., batch: Optional[Batch] = ..., group: Optional[Group] = ..., program: Optional[ShaderProgram] = ..., wrap_lines: bool = ...) -> None:
        ...
    
    def delete(self) -> None:
        ...
    
    def on_insert_text(self, start: int, text: str) -> None:
        ...
    
    def on_delete_text(self, start: int, end: int) -> None:
        ...
    
    def on_style_text(self, start: int, end: int, attributes: dict[str, Any]) -> None:
        ...
    
    @property
    def x(self) -> float:
        ...
    
    @x.setter
    def x(self, x: float) -> None:
        ...
    
    @property
    def y(self) -> float:
        ...
    
    @y.setter
    def y(self, y: float) -> None:
        ...
    
    @property
    def z(self) -> float:
        ...
    
    @z.setter
    def z(self, z: float) -> None:
        ...
    
    @property
    def position(self) -> Tuple[float, float, float]:
        ...
    
    @position.setter
    def position(self, position: Tuple[float, float, float]) -> None:
        ...
    
    @property
    def anchor_x(self) -> AnchorX:
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x: AnchorX) -> None:
        ...
    
    @property
    def anchor_y(self) -> AnchorY:
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y: AnchorY) -> None:
        ...
    
    @property
    def width(self) -> int:
        ...
    
    @width.setter
    def width(self, width: int) -> None:
        ...
    
    @property
    def height(self) -> int:
        ...
    
    @height.setter
    def height(self, height: int) -> None:
        ...
    
    @property
    def multiline(self) -> bool:
        ...
    
    @multiline.setter
    def multiline(self, multiline: bool) -> None:
        ...
    
    @property
    def rotation(self) -> float:
        ...
    
    @rotation.setter
    def rotation(self, angle: float) -> None:
        ...
    
    @property
    def view_x(self) -> int:
        """Horizontal scroll offset.

        The initial value is 0, and the left edge of the text will touch the left
        side of the layout bounds.  A positive value causes the text to "scroll"
        to the right.  Values are automatically clipped into the range
        ``[0, content_width - width]``

        :type: int
        """
        ...
    
    @view_x.setter
    def view_x(self, view_x: int) -> None:
        ...
    
    @property
    def view_y(self) -> int:
        """Vertical scroll offset.

        The initial value is 0, and the top of the text will touch the top of the
        layout bounds (unless the content height is less than the layout height,
        in which case `content_valign` is used).

        A negative value causes the text to "scroll" upwards.  Values outside of
        the range ``[height - content_height, 0]`` are automatically clipped in
        range.

        :type: int
        """
        ...
    
    @view_y.setter
    def view_y(self, view_y: int) -> None:
        ...
    
    def set_selection(self, start: int, end: int) -> None:
        """Set the text selection range.

        If ``start`` equals ``end`` no selection will be visible.

        :Parameters:
            `start` : int
                Starting character position of selection.
            `end` : int
                End of selection, exclusive.

        """
        ...
    
    @property
    def selection_start(self) -> int:
        """Starting position of the active selection.

        :see: `set_selection`

        :type: int
        """
        ...
    
    @selection_start.setter
    def selection_start(self, start: int) -> None:
        ...
    
    @property
    def selection_end(self) -> int:
        """End position of the active selection (exclusive).

        :see: `set_selection`

        :type: int
        """
        ...
    
    @selection_end.setter
    def selection_end(self, end: int) -> None:
        ...
    
    @property
    def selection_color(self) -> Tuple[int, int, int, int]:
        """Text color of active selection.

        The color is an RGBA tuple with components in range [0, 255].

        :type: (int, int, int, int)
        """
        ...
    
    @selection_color.setter
    def selection_color(self, color: Tuple[int, int, int, int]) -> None:
        ...
    
    @property
    def selection_background_color(self) -> Tuple[int, int, int, int]:
        """Background color of active selection.

        The color is an RGBA tuple with components in range [0, 255].

        :type: (int, int, int, int)
        """
        ...
    
    @selection_background_color.setter
    def selection_background_color(self, background_color: Tuple[int, int, int, int]) -> None:
        ...
    
    def get_position_from_point(self, x: float, y: float) -> int:
        """Get the closest document position to a point.

        :Parameters:
            `x` : int
                X coordinate
            `y` : int
                Y coordinate

        """
        ...
    
    def get_point_from_position(self, position, line=...): # -> tuple[float | Any | int, Any]:
        """Get the X, Y coordinates of a position in the document.

        The position that ends a line has an ambiguous point: it can be either
        the end of the line, or the beginning of the next line.  You may
        optionally specify a line index to disambiguate the case.

        The resulting Y coordinate gives the baseline of the line.

        :Parameters:
            `position` : int
                Character position within document.
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        """
        ...
    
    def get_line_from_point(self, x, y): # -> int:
        """Get the closest line index to a point.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        :rtype: int
        """
        ...
    
    def get_point_from_line(self, line): # -> tuple[Any, Any]:
        """Get the X, Y coordinates of a line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        """
        ...
    
    def get_line_from_position(self, position): # -> int:
        """Get the line index of a character position in the document.

        :Parameters:
            `position` : int
                Document position.

        :rtype: int
        """
        ...
    
    def get_position_from_line(self, line):
        """Get the first document character position of a given line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: int
        """
        ...
    
    def get_position_on_line(self, line_idx: int, x: float) -> int:
        """Get the closest document position for a given line index and X
        coordinate.

        :Parameters:
            `line` : int
                Line index.
            `x` : int
                X coordinate.

        :rtype: int
        """
        ...
    
    def get_line_count(self) -> int:
        """Get the number of lines in the text layout.

        :rtype: int
        """
        ...
    
    def ensure_line_visible(self, line_idx: int) -> None:
        """Adjust `view_y` so that the line with the given index is visible.

        :Parameters:
            `line` : int
                Line index.

        """
        ...
    
    def ensure_x_visible(self, x: int) -> None:
        """Adjust `view_x` so that the given X coordinate is visible.

        The X coordinate is given relative to the current `view_x`.

        :Parameters:
            `x` : int
                X coordinate

        """
        ...
    
    if _is_pyglet_doc_run:
        def on_layout_update(self): # -> None:
            """Some or all of the layout text was reflowed.

            Text reflow is caused by document edits or changes to the layout's
            size.  Changes to the layout's position or active selection, and
            certain document edits such as text color, do not cause a reflow.

            Handle this event to update the position of a graphical element
            that depends on the laid out position of a glyph or line.

            :event:
            """
            ...
        


