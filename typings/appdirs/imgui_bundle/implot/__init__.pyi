"""
This type stub file was generated by pyright.
"""

import numpy as np
import enum
from typing import Any, Optional, Tuple, overload
from imgui_bundle.imgui import ImDrawList, ImU32, ImVec2, ImVec4, ImVector_ColorMod, ImVector_ImU32, ImVector_StyleMod, ImVector_float, ImVector_int, Storage, TextBuffer
from imgui_bundle.imgui.internal import ImRect
from imgui_bundle import imgui
from imgui_bundle.implot import AxisFlags, Cond, Flags, IMPLOT_AUTO, ImAxis, InputMap, ItemFlags, LegendFlags, Location, Marker, MouseTextFlags, Point, Range, Scale, Style, SubplotFlags

"""ImPlot: Immediate Mode Plotting for ImGui
Python bindings for https://github.com/epezent/implot
"""
ImGui_Context = imgui.internal.Context
Colormap = int
ID = int
TimeUnit = int
TimeFmt = int
DateFmt = int
Col = int
Bin = int
time_t = int
@overload
def im_log10(x: float) -> float:
    """(private API)"""
    ...

@overload
def im_log10(x: float) -> float:
    """(private API)"""
    ...

@overload
def im_sinh(x: float) -> float:
    """(private API)"""
    ...

@overload
def im_sinh(x: float) -> float:
    """(private API)"""
    ...

@overload
def im_asinh(x: float) -> float:
    """(private API)"""
    ...

@overload
def im_asinh(x: float) -> float:
    """(private API)"""
    ...

def im_pos_mod(l: int, r: int) -> int:
    """ Returns always positive modulo (assumes r != 0)
    (private API)
    """
    ...

def im_nan(val: float) -> bool:
    """ Returns True if val is NAN
    (private API)
    """
    ...

def im_nan_or_inf(val: float) -> bool:
    """ Returns True if val is NAN or INFINITY
    (private API)
    """
    ...

def im_constrain_nan(val: float) -> float:
    """ Turns NANs to 0s
    (private API)
    """
    ...

def im_constrain_inf(val: float) -> float:
    """ Turns infinity to floating point maximums
    (private API)
    """
    ...

def im_constrain_log(val: float) -> float:
    """ Turns numbers less than or equal to 0 to 0.001 (sort of arbitrary, is there a better way?)
    (private API)
    """
    ...

def im_constrain_time(val: float) -> float:
    """ Turns numbers less than 0 to zero
    (private API)
    """
    ...

def im_almost_equal(v1: float, v2: float, ulp: int = ...) -> bool:
    """ True if two numbers are approximately equal using units in the last place.
    (private API)
    """
    ...

def im_mix_u32(a: ImU32, b: ImU32, s: ImU32) -> ImU32:
    """ Mix color a and b by factor s in [0 256]
    (private API)
    """
    ...

def im_lerp_u32(colors: ImU32, size: int, t: float) -> ImU32:
    """ Lerp across an array of 32-bit collors given t in [0.0 1.0]
    (private API)
    """
    ...

def im_alpha_u32(col: ImU32, alpha: float) -> ImU32:
    """ Set alpha channel of 32-bit color from float in range [0.0 1.0]
    (private API)
    """
    ...

class TimeUnit_(enum.Enum):
    us = ...
    ms = ...
    s = ...
    min = ...
    hr = ...
    day = ...
    mo = ...
    yr = ...
    count = ...


class DateFmt_(enum.Enum):
    none = ...
    day_mo = ...
    day_mo_yr = ...
    mo_yr = ...
    mo = ...
    yr = ...


class TimeFmt_(enum.Enum):
    none = ...
    us = ...
    s_us = ...
    s_ms = ...
    s = ...
    min_s_ms = ...
    hr_min_s_ms = ...
    hr_min_s = ...
    hr_min = ...
    hr = ...


class DateTimeSpec:
    """ Combined date/time format spec"""
    @overload
    def __init__(self) -> None:
        ...
    
    @overload
    def __init__(self, date_fmt: DateFmt, time_fmt: TimeFmt, use_24_hr_clk: bool = ..., use_iso_8601: bool = ...) -> None:
        ...
    
    date: DateFmt
    time: TimeFmt
    use_iso8601: bool
    use24_hour_clock: bool


class Time:
    """ Two part timestamp struct."""
    s: time_t
    us: int
    @overload
    def __init__(self) -> None:
        ...
    
    @overload
    def __init__(self, s: time_t, us: int = ...) -> None:
        ...
    
    def roll_over(self) -> None:
        """(private API)"""
        ...
    
    def to_double(self) -> float:
        """(private API)"""
        ...
    
    @staticmethod
    def from_double(t: float) -> Time:
        """(private API)"""
        ...
    


class ColormapData:
    """ Colormap data storage"""
    keys: ImVector_ImU32
    key_counts: ImVector_int
    key_offsets: ImVector_int
    tables: ImVector_ImU32
    table_sizes: ImVector_int
    table_offsets: ImVector_int
    text: TextBuffer
    text_offsets: ImVector_int
    map: Storage
    count: int
    def __init__(self) -> None:
        ...
    
    def append(self, name: str, keys: ImU32, count: int, qual: bool) -> int:
        """(private API)"""
        ...
    
    def rebuild_tables(self) -> None:
        """(private API)"""
        ...
    
    def is_qual(self, cmap: Colormap) -> bool:
        """(private API)"""
        ...
    
    def get_name(self, cmap: Colormap) -> str:
        """(private API)"""
        ...
    
    def get_index(self, name: str) -> Colormap:
        """(private API)"""
        ...
    
    def get_keys(self, cmap: Colormap) -> ImU32:
        """(private API)"""
        ...
    
    def get_key_count(self, cmap: Colormap) -> int:
        """(private API)"""
        ...
    
    def get_key_color(self, cmap: Colormap, idx: int) -> ImU32:
        """(private API)"""
        ...
    
    def set_key_color(self, cmap: Colormap, idx: int, value: ImU32) -> None:
        """(private API)"""
        ...
    
    def get_table(self, cmap: Colormap) -> ImU32:
        """(private API)"""
        ...
    
    def get_table_size(self, cmap: Colormap) -> int:
        """(private API)"""
        ...
    
    def get_table_color(self, cmap: Colormap, idx: int) -> ImU32:
        """(private API)"""
        ...
    
    def lerp_table(self, cmap: Colormap, t: float) -> ImU32:
        """(private API)"""
        ...
    


class PointError:
    """ ImPlotPoint with positive/negative error values"""
    x: float
    y: float
    neg: float
    pos: float
    def __init__(self, x: float, y: float, neg: float, pos: float) -> None:
        ...
    


class Annotation:
    """ Interior plot label/annotation"""
    pos: ImVec2
    offset: ImVec2
    color_bg: ImU32
    color_fg: ImU32
    text_offset: int
    clamp: bool
    def __init__(self) -> None:
        ...
    


class AnnotationCollection:
    """ Collection of plot labels"""
    text_buffer: TextBuffer
    size: int
    def __init__(self) -> None:
        ...
    
    def append(self, pos: ImVec2, off: ImVec2, bg: ImU32, fg: ImU32, clamp: bool, fmt: str) -> None:
        """(private API)"""
        ...
    
    def get_text(self, idx: int) -> str:
        """(private API)"""
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class Tag:
    axis: ImAxis
    value: float
    color_bg: ImU32
    color_fg: ImU32
    text_offset: int
    def __init__(self, axis: ImAxis = ..., value: float = ..., color_bg: ImU32 = ..., color_fg: ImU32 = ..., text_offset: int = ...) -> None:
        """Auto-generated default constructor with named params"""
        ...
    


class TagCollection:
    text_buffer: TextBuffer
    size: int
    def __init__(self) -> None:
        ...
    
    def append(self, axis: ImAxis, value: float, bg: ImU32, fg: ImU32, fmt: str) -> None:
        """(private API)"""
        ...
    
    def get_text(self, idx: int) -> str:
        """(private API)"""
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class Tick:
    """ Tick mark info"""
    plot_pos: float
    pixel_pos: float
    label_size: ImVec2
    text_offset: int
    major: bool
    show_label: bool
    level: int
    idx: int
    def __init__(self, value: float, major: bool, level: int, show_label: bool) -> None:
        ...
    


class Ticker:
    """ Collection of ticks"""
    text_buffer: TextBuffer
    max_size: ImVec2
    late_size: ImVec2
    levels: int
    def __init__(self) -> None:
        ...
    
    @overload
    def add_tick(self, value: float, major: bool, level: int, show_label: bool, label: str) -> Tick:
        """(private API)"""
        ...
    
    @overload
    def add_tick(self, tick: Tick) -> Tick:
        """(private API)"""
        ...
    
    @overload
    def get_text(self, idx: int) -> str:
        """(private API)"""
        ...
    
    @overload
    def get_text(self, tick: Tick) -> str:
        """(private API)"""
        ...
    
    def override_size_late(self, size: ImVec2) -> None:
        """(private API)"""
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    
    def tick_count(self) -> int:
        """(private API)"""
        ...
    


class Axis:
    """ Axis state information that must persist after EndPlot"""
    id_: ID
    flags: AxisFlags
    previous_flags: AxisFlags
    range: Range
    range_cond: Cond
    scale: Scale
    fit_extents: Range
    ortho_axis: Axis
    constraint_range: Range
    constraint_zoom: Range
    ticker: Ticker
    formatter_data: Any
    linked_min: float
    linked_max: float
    picker_level: int
    picker_time_min: Time
    picker_time_max: Time
    transform_data: Any
    pixel_min: float
    pixel_max: float
    scale_min: float
    scale_max: float
    scale_to_pixel: float
    datum1: float
    datum2: float
    hover_rect: ImRect
    label_offset: int
    color_maj: ImU32
    color_min: ImU32
    color_tick: ImU32
    color_txt: ImU32
    color_bg: ImU32
    color_hov: ImU32
    color_act: ImU32
    color_hi_li: ImU32
    enabled: bool
    vertical: bool
    fit_this_frame: bool
    has_range: bool
    has_format_spec: bool
    show_default_ticks: bool
    hovered: bool
    held: bool
    def __init__(self) -> None:
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    
    def set_min(self, _min: float, force: bool = ...) -> bool:
        """(private API)"""
        ...
    
    def set_max(self, _max: float, force: bool = ...) -> bool:
        """(private API)"""
        ...
    
    @overload
    def set_range(self, v1: float, v2: float) -> None:
        """(private API)"""
        ...
    
    @overload
    def set_range(self, range: Range) -> None:
        """(private API)"""
        ...
    
    def set_aspect(self, unit_per_pix: float) -> None:
        """(private API)"""
        ...
    
    def pixel_size(self) -> float:
        """(private API)"""
        ...
    
    def get_aspect(self) -> float:
        """(private API)"""
        ...
    
    def constrain(self) -> None:
        """(private API)"""
        ...
    
    def update_transform_cache(self) -> None:
        """(private API)"""
        ...
    
    def plot_to_pixels(self, plt: float) -> float:
        """(private API)"""
        ...
    
    def pixels_to_plot(self, pix: float) -> float:
        """(private API)"""
        ...
    
    def extend_fit(self, v: float) -> None:
        """(private API)"""
        ...
    
    def extend_fit_with(self, alt: Axis, v: float, v_alt: float) -> None:
        """(private API)"""
        ...
    
    def apply_fit(self, padding: float) -> None:
        """(private API)"""
        ...
    
    def has_label(self) -> bool:
        """(private API)"""
        ...
    
    def has_grid_lines(self) -> bool:
        """(private API)"""
        ...
    
    def has_tick_labels(self) -> bool:
        """(private API)"""
        ...
    
    def has_tick_marks(self) -> bool:
        """(private API)"""
        ...
    
    def will_render(self) -> bool:
        """(private API)"""
        ...
    
    def is_opposite(self) -> bool:
        """(private API)"""
        ...
    
    def is_inverted(self) -> bool:
        """(private API)"""
        ...
    
    def is_foreground(self) -> bool:
        """(private API)"""
        ...
    
    def is_auto_fitting(self) -> bool:
        """(private API)"""
        ...
    
    def can_init_fit(self) -> bool:
        """(private API)"""
        ...
    
    def is_range_locked(self) -> bool:
        """(private API)"""
        ...
    
    def is_locked_min(self) -> bool:
        """(private API)"""
        ...
    
    def is_locked_max(self) -> bool:
        """(private API)"""
        ...
    
    def is_locked(self) -> bool:
        """(private API)"""
        ...
    
    def is_input_locked_min(self) -> bool:
        """(private API)"""
        ...
    
    def is_input_locked_max(self) -> bool:
        """(private API)"""
        ...
    
    def is_input_locked(self) -> bool:
        """(private API)"""
        ...
    
    def has_menus(self) -> bool:
        """(private API)"""
        ...
    
    def is_pan_locked(self, increasing: bool) -> bool:
        """(private API)"""
        ...
    
    def push_links(self) -> None:
        """(private API)"""
        ...
    
    def pull_links(self) -> None:
        """(private API)"""
        ...
    


class AlignmentData:
    """ Align plots group data"""
    vertical: bool
    pad_a: float
    pad_b: float
    pad_a_max: float
    pad_b_max: float
    def __init__(self) -> None:
        ...
    
    def begin(self) -> None:
        """(private API)"""
        ...
    
    def update(self, pad_a: float, pad_b: float, delta_a: float, delta_b: float) -> Tuple[float, float, float, float]:
        """(private API)"""
        ...
    
    def end(self) -> None:
        """(private API)"""
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class Item:
    """ State information for Plot items"""
    id_: ID
    color: ImU32
    legend_hover_rect: ImRect
    name_offset: int
    show: bool
    legend_hovered: bool
    seen_this_frame: bool
    def __init__(self) -> None:
        ...
    


class Legend:
    """ Holds Legend state"""
    flags: LegendFlags
    previous_flags: LegendFlags
    location: Location
    previous_location: Location
    scroll: ImVec2
    indices: ImVector_int
    labels: TextBuffer
    rect: ImRect
    rect_clamped: ImRect
    hovered: bool
    held: bool
    can_go_inside: bool
    def __init__(self) -> None:
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class ItemGroup:
    """ Holds Items and Legend data"""
    id_: ID
    legend: Legend
    colormap_idx: int
    def __init__(self) -> None:
        ...
    
    def get_item_count(self) -> int:
        """(private API)"""
        ...
    
    def get_item_id(self, label_id: str) -> ID:
        """(private API)"""
        ...
    
    @overload
    def get_item(self, id_: ID) -> Item:
        """(private API)"""
        ...
    
    @overload
    def get_item(self, label_id: str) -> Item:
        """(private API)"""
        ...
    
    def get_or_add_item(self, id_: ID) -> Item:
        """(private API)"""
        ...
    
    def get_item_by_index(self, i: int) -> Item:
        """(private API)"""
        ...
    
    def get_item_index(self, item: Item) -> int:
        """(private API)"""
        ...
    
    def get_legend_count(self) -> int:
        """(private API)"""
        ...
    
    def get_legend_item(self, i: int) -> Item:
        """(private API)"""
        ...
    
    def get_legend_label(self, i: int) -> str:
        """(private API)"""
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class Plot:
    """ Holds Plot state information that must persist after EndPlot"""
    id_: ID
    flags: Flags
    previous_flags: Flags
    mouse_text_location: Location
    mouse_text_flags: MouseTextFlags
    text_buffer: TextBuffer
    items: ItemGroup
    current_x: ImAxis
    current_y: ImAxis
    frame_rect: ImRect
    canvas_rect: ImRect
    plot_rect: ImRect
    axes_rect: ImRect
    select_rect: ImRect
    select_start: ImVec2
    title_offset: int
    just_created: bool
    initialized: bool
    setup_locked: bool
    fit_this_frame: bool
    hovered: bool
    held: bool
    selecting: bool
    selected: bool
    context_locked: bool
    def __init__(self) -> None:
        ...
    
    def is_input_locked(self) -> bool:
        """(private API)"""
        ...
    
    def clear_text_buffer(self) -> None:
        """(private API)"""
        ...
    
    def set_title(self, title: str) -> None:
        """(private API)"""
        ...
    
    def has_title(self) -> bool:
        """(private API)"""
        ...
    
    def get_title(self) -> str:
        """(private API)"""
        ...
    
    @overload
    def x_axis(self, i: int) -> Axis:
        """(private API)"""
        ...
    
    @overload
    def x_axis(self, i: int) -> Axis:
        """(private API)"""
        ...
    
    @overload
    def y_axis(self, i: int) -> Axis:
        """(private API)"""
        ...
    
    @overload
    def y_axis(self, i: int) -> Axis:
        """(private API)"""
        ...
    
    def enabled_axes_x(self) -> int:
        """(private API)"""
        ...
    
    def enabled_axes_y(self) -> int:
        """(private API)"""
        ...
    
    def set_axis_label(self, axis: Axis, label: str) -> None:
        """(private API)"""
        ...
    
    def get_axis_label(self, axis: Axis) -> str:
        """(private API)"""
        ...
    


class Subplot:
    """ Holds subplot data that must persist after EndSubplot"""
    id_: ID
    flags: SubplotFlags
    previous_flags: SubplotFlags
    items: ItemGroup
    rows: int
    cols: int
    current_idx: int
    frame_rect: ImRect
    grid_rect: ImRect
    cell_size: ImVec2
    row_ratios: ImVector_float
    col_ratios: ImVector_float
    temp_sizes: np.ndarray
    frame_hovered: bool
    has_title: bool
    def __init__(self) -> None:
        ...
    


class NextPlotData:
    """ Temporary data storage for upcoming plot"""
    def __init__(self) -> None:
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class NextItemData:
    """ Temporary data storage for upcoming item"""
    line_weight: float
    marker: Marker
    marker_size: float
    marker_weight: float
    fill_alpha: float
    error_bar_size: float
    error_bar_weight: float
    digital_bit_height: float
    digital_bit_gap: float
    render_line: bool
    render_fill: bool
    render_marker_line: bool
    render_marker_fill: bool
    has_hidden: bool
    hidden: bool
    hidden_cond: Cond
    def __init__(self) -> None:
        ...
    
    def reset(self) -> None:
        """(private API)"""
        ...
    


class Context:
    """ Holds state information that must persist between calls to BeginPlot()/EndPlot()"""
    current_plot: Plot
    current_subplot: Subplot
    current_items: ItemGroup
    current_item: Item
    previous_item: Item
    c_ticker: Ticker
    annotations: AnnotationCollection
    tags: TagCollection
    style: Style
    color_modifiers: ImVector_ColorMod
    style_modifiers: ImVector_StyleMod
    colormap_data: ColormapData
    temp_int1: ImVector_int
    digital_plot_item_cnt: int
    digital_plot_offset: int
    next_plot_data: NextPlotData
    next_item_data: NextItemData
    input_map: InputMap
    open_context_this_frame: bool
    mouse_pos_string_builder: TextBuffer
    sort_items: ItemGroup
    current_alignment_h: AlignmentData
    current_alignment_v: AlignmentData
    def __init__(self, c_ticker: Ticker = ..., annotations: AnnotationCollection = ..., tags: TagCollection = ..., style: Style = ..., color_modifiers: ImVector_ColorMod = ..., style_modifiers: ImVector_StyleMod = ..., colormap_data: ColormapData = ..., temp_int1: ImVector_int = ..., digital_plot_item_cnt: int = ..., digital_plot_offset: int = ..., next_plot_data: NextPlotData = ..., next_item_data: NextItemData = ..., input_map: InputMap = ..., open_context_this_frame: bool = ..., mouse_pos_string_builder: TextBuffer = ...) -> None:
        """Auto-generated default constructor with named params"""
        ...
    


def initialize(ctx: Context) -> None:
    """ Initializes an ImPlotContext"""
    ...

def reset_ctx_for_next_plot(ctx: Context) -> None:
    """ Resets an ImPlot context for the next call to BeginPlot"""
    ...

def reset_ctx_for_next_aligned_plots(ctx: Context) -> None:
    """ Resets an ImPlot context for the next call to BeginAlignedPlots"""
    ...

def reset_ctx_for_next_subplot(ctx: Context) -> None:
    """ Resets an ImPlot context for the next call to BeginSubplot"""
    ...

def get_plot(title: str) -> Plot:
    """ Gets a plot from the current ImPlotContext"""
    ...

def get_current_plot() -> Plot:
    """ Gets the current plot from the current ImPlotContext"""
    ...

def bust_plot_cache() -> None:
    """ Busts the cache for every plot in the current context"""
    ...

def show_plot_context_menu(plot: Plot) -> None:
    """ Shows a plot's context menu."""
    ...

def setup_lock() -> None:
    """ Lock Setup and call SetupFinish if necessary.
    (private API)
    """
    ...

def subplot_next_cell() -> None:
    """ Advances to next subplot"""
    ...

def show_subplots_context_menu(subplot: Subplot) -> None:
    """ Shows a subplot's context menu."""
    ...

def begin_item(label_id: str, flags: ItemFlags = ..., recolor_from: Col = ...) -> bool:
    """ Begins a new item. Returns False if the item should not be plotted. Pushes PlotClipRect."""
    ...

def end_item() -> None:
    """ Ends an item (call only if BeginItem returns True). Pops PlotClipRect."""
    ...

def register_or_get_item(label_id: str, flags: ItemFlags, just_created: Optional[bool] = ...) -> Tuple[Item, Optional[bool]]:
    """ Register or get an existing item from the current plot."""
    ...

def get_item(label_id: str) -> Item:
    """ Get a plot item from the current plot."""
    ...

def get_current_item() -> Item:
    """ Gets the current item."""
    ...

def bust_item_cache() -> None:
    """ Busts the cache for every item for every plot in the current context."""
    ...

def any_axes_input_locked(axes: Axis, count: int) -> bool:
    """ Returns True if any enabled axis is locked from user input.
    (private API)
    """
    ...

def all_axes_input_locked(axes: Axis, count: int) -> bool:
    """ Returns True if all enabled axes are locked from user input.
    (private API)
    """
    ...

def any_axes_held(axes: Axis, count: int) -> bool:
    """(private API)"""
    ...

def any_axes_hovered(axes: Axis, count: int) -> bool:
    """(private API)"""
    ...

def fit_this_frame() -> bool:
    """ Returns True if the user has requested data to be fit.
    (private API)
    """
    ...

def fit_point_x(x: float) -> None:
    """ Extends the current plot's axes so that it encompasses a vertical line at x
    (private API)
    """
    ...

def fit_point_y(y: float) -> None:
    """ Extends the current plot's axes so that it encompasses a horizontal line at y
    (private API)
    """
    ...

def fit_point(p: Point) -> None:
    """ Extends the current plot's axes so that it encompasses point p
    (private API)
    """
    ...

def ranges_overlap(r1: Range, r2: Range) -> bool:
    """ Returns True if two ranges overlap
    (private API)
    """
    ...

def show_axis_context_menu(axis: Axis, equal_axis: Axis, time_allowed: bool = ...) -> None:
    """ Shows an axis's context menu."""
    ...

def get_location_pos(outer_rect: ImRect, inner_size: ImVec2, location: Location, pad: ImVec2 = ...) -> ImVec2:
    """ Gets the position of an inner rect that is located inside of an outer rect according to an ImPlotLocation and padding amount."""
    ...

def calc_legend_size(items: ItemGroup, pad: ImVec2, spacing: ImVec2, vertical: bool) -> ImVec2:
    """ Calculates the bounding box size of a legend _before_ clipping."""
    ...

def clamp_legend_rect(legend_rect: ImRect, outer_rect: ImRect, pad: ImVec2) -> bool:
    """ Clips calculated legend size"""
    ...

def show_legend_entries(items: ItemGroup, legend_bb: ImRect, interactable: bool, pad: ImVec2, spacing: ImVec2, vertical: bool, draw_list: ImDrawList) -> bool:
    """ Renders legend entries into a bounding box"""
    ...

def show_alt_legend(title_id: str, vertical: bool = ..., size: ImVec2 = ..., interactable: bool = ...) -> None:
    """ Shows an alternate legend for the plot identified by #title_id, outside of the plot frame (can be called before or after of Begin/EndPlot but must occur in the same ImGui window! This is not thoroughly tested nor scrollable!)."""
    ...

def show_legend_context_menu(legend: Legend, visible: bool) -> bool:
    """ Shows a legend's context menu."""
    ...

def get_item_data() -> NextItemData:
    """ Get styling data for next item (call between Begin/EndItem)
    (private API)
    """
    ...

@overload
def is_color_auto(col: ImVec4) -> bool:
    """ Returns True if a color is set to be automatically determined
    (private API)
    """
    ...

@overload
def is_color_auto(idx: Col) -> bool:
    """ Returns True if a style color is set to be automatically determined
    (private API)
    """
    ...

def get_auto_color(idx: Col) -> ImVec4:
    """ Returns the automatically deduced style color"""
    ...

def get_style_color_vec4(idx: Col) -> ImVec4:
    """(private API)"""
    ...

def get_style_color_u32(idx: Col) -> ImU32:
    """(private API)"""
    ...

def add_text_vertical(draw_list: ImDrawList, pos: ImVec2, col: ImU32, text_begin: str, text_end: Optional[str] = ...) -> None:
    """ Draws vertical text. The position is the bottom left of the text rect."""
    ...

def add_text_centered(draw_list: ImDrawList, top_center: ImVec2, col: ImU32, text_begin: str, text_end: Optional[str] = ...) -> None:
    """ Draws multiline horizontal text centered."""
    ...

def calc_text_size_vertical(text: str) -> ImVec2:
    """ Calculates the size of vertical text
    (private API)
    """
    ...

@overload
def calc_text_color(bg: ImVec4) -> ImU32:
    """(private API)"""
    ...

@overload
def calc_text_color(bg: ImU32) -> ImU32:
    """(private API)"""
    ...

def calc_hover_color(col: ImU32) -> ImU32:
    """ Lightens or darkens a color for hover
    (private API)
    """
    ...

def clamp_label_pos(pos: ImVec2, size: ImVec2, min: ImVec2, max: ImVec2) -> ImVec2:
    """ Clamps a label position so that it fits a rect defined by Min/Max
    (private API)
    """
    ...

def get_colormap_color_u32(idx: int, cmap: Colormap) -> ImU32:
    """ Returns a color from the Color map given an index >= 0 (modulo will be performed)."""
    ...

def next_colormap_color_u32() -> ImU32:
    """ Returns the next unused colormap color and advances the colormap. Can be used to skip colors if desired."""
    ...

def sample_colormap_u32(t: float, cmap: Colormap) -> ImU32:
    """ Linearly interpolates a color from the current colormap given t between 0 and 1."""
    ...

def render_color_bar(colors: ImU32, size: int, draw_list: ImDrawList, bounds: ImRect, vert: bool, reversed: bool, continuous: bool) -> None:
    """ Render a colormap bar"""
    ...

def nice_num(x: float, round: bool) -> float:
    """ Rounds x to powers of 2,5 and 10 for generating axis labels (from Graphics Gems 1 Chapter 11.2)"""
    ...

def order_of_magnitude(val: float) -> int:
    """ Computes order of magnitude of double.
    (private API)
    """
    ...

def order_to_precision(order: int) -> int:
    """ Returns the precision required for a order of magnitude.
    (private API)
    """
    ...

def precision(val: float) -> int:
    """ Returns a floating point precision to use given a value
    (private API)
    """
    ...

def round_to(val: float, prec: int) -> float:
    """ Round a value to a given precision
    (private API)
    """
    ...

def intersection(a1: ImVec2, a2: ImVec2, b1: ImVec2, b2: ImVec2) -> ImVec2:
    """ Returns the intersection point of two lines A and B (assumes they are not parallel!)
    (private API)
    """
    ...

def is_leap_year(year: int) -> bool:
    """ Returns True if year is leap year (366 days long)
    (private API)
    """
    ...

def get_days_in_month(year: int, month: int) -> int:
    """ Returns the number of days in a month, accounting for Feb. leap years. #month is zero indexed.
    (private API)
    """
    ...

def make_time(year: int, month: int = ..., day: int = ..., hour: int = ..., min: int = ..., sec: int = ..., us: int = ...) -> Time:
    """ Make a timestamp from time components.
     year[1970-3000], month[0-11], day[1-31], hour[0-23], min[0-59], sec[0-59], us[0,999999]
    """
    ...

def get_year(t: Time) -> int:
    """ Get year component from timestamp [1970-3000]"""
    ...

def add_time(t: Time, unit: TimeUnit, count: int) -> Time:
    """ Adds or subtracts time from a timestamp. #count > 0 to add, < 0 to subtract."""
    ...

def floor_time(t: Time, unit: TimeUnit) -> Time:
    """ Rounds a timestamp down to nearest unit."""
    ...

def ceil_time(t: Time, unit: TimeUnit) -> Time:
    """ Rounds a timestamp up to the nearest unit."""
    ...

def round_time(t: Time, unit: TimeUnit) -> Time:
    """ Rounds a timestamp up or down to the nearest unit."""
    ...

def combine_date_time(date_part: Time, time_part: Time) -> Time:
    """ Combines the date of one timestamp with the time-of-day of another timestamp."""
    ...

def show_date_picker(id_: str, level: int, t: Time, t1: Optional[Time] = ..., t2: Optional[Time] = ...) -> Tuple[bool, int]:
    """ Shows a date picker widget block (year/month/day).
     #level = 0 for day, 1 for month, 2 for year. Modified by user interaction.
     #t will be set when a day is clicked and the function will return True.
     #t1 and #t2 are optional dates to highlight.
    """
    ...

def show_time_picker(id_: str, t: Time) -> bool:
    """ Shows a time picker widget block (hour/min/sec).
     #t will be set when a new hour, minute, or sec is selected or am/pm is toggled, and the function will return True.
    """
    ...

def transform_forward_log10(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

def transform_inverse_log10(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

def transform_forward_sym_log(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

def transform_inverse_sym_log(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

def transform_forward_logit(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

def transform_inverse_logit(v: float, param_1: Any) -> float:
    """(private API)"""
    ...

class Formatter_Time_Data:
    time: Time
    spec: DateTimeSpec
    user_formatter_data: Any
    def __init__(self, time: Time = ..., spec: DateTimeSpec = ...) -> None:
        """Auto-generated default constructor with named params"""
        ...
    


