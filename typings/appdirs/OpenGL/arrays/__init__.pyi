"""
This type stub file was generated by pyright.
"""

import ctypes
import logging
import weakref
from OpenGL.arrays.arraydatatype import ArrayDatatype
from OpenGL.arrays.formathandler import FormatHandler
from OpenGL.raw.GL import _types
from OpenGL import acceleratesupport, error
from OpenGL._bytes import as_8_bit, bytes, integer_types, long, unicode
from OpenGL_accelerate.vbo import VBO, VBOHandler, VBOOffset, VBOOffsetHandler

"""VertexBufferObject helper class

Basic usage:

    my_data = numpy.array( data, 'f')
    my_vbo = vbo.VBO( my_data )
    ...
    my_vbo.bind()
    try:
        ...
        glVertexPointer( my_vbo, ... )
        ...
        glNormalPointer( my_vbo + 12, ... )
    finally:
        my_vbo.unbind()
    
    or 
    
    with my_vbo:
        ...
        glVertexPointer( my_vbo, ... )
        ...
        glNormalPointer( my_vbo + 12, ... )        

See the OpenGLContext shader tutorials for a gentle introduction on the 
usage of VBO objects:

    http://pyopengl.sourceforge.net/context/tutorials/shader_intro.xhtml

This implementation will choose either the ARB or Core (OpenGL 1.5) 
implementation of the VBO functions.
"""
_log = ...
__all__ = ('VBO', 'VBOHandler', 'mapVBO')
class Implementation:
    """Abstraction point for the various implementations that can be used
    """
    IMPLEMENTATION_CLASSES = ...
    CHOSEN = ...
    @classmethod
    def register(cls): # -> None:
        ...
    
    @classmethod
    def get_implementation(cls, *args): # -> None:
        ...
    
    EXPORTED_NAMES = ...
    available = ...
    def basename(self, name):
        ...
    
    def __nonzero__(self): # -> bool:
        ...
    
    __bool__ = ...
    def deleter(self, buffers, key): # -> Callable[..., None]:
        """Produce a deleter callback to delete the given buffer"""
        ...
    
    _DELETERS_ = ...


get_implementation = ...
VBO = ...
if acceleratesupport.ACCELERATE_AVAILABLE:
    ...
if VBO is None:
    class VBO:
        """Instances can be passed into array-handling routines

        You can check for whether VBOs are supported by accessing the implementation:

            if bool(vbo.get_implementation()):
                # vbo version of code
            else:
                # fallback version of code
        """
        copied = ...
        _no_cache_ = ...
        def __init__(self, data, usage=..., target=..., size=...) -> None:
            """Initialize the VBO object 
            
            data -- PyOpenGL-compatible array-data structure, numpy arrays, ctypes arrays, etc.
            usage -- OpenGL usage constant describing expected data-flow patterns (this is a hint 
                to the GL about where/how to cache the data)
                
                GL_STATIC_DRAW_ARB
                GL_STATIC_READ_ARB
                GL_STATIC_COPY_ARB
                GL_DYNAMIC_DRAW_ARB
                GL_DYNAMIC_READ_ARB
                GL_DYNAMIC_COPY_ARB
                GL_STREAM_DRAW_ARB
                GL_STREAM_READ_ARB
                GL_STREAM_COPY_ARB
                
                DRAW constants suggest to the card that the data will be primarily used to draw 
                on the card.  READ that the data will be read back into the GL.  COPY means that 
                the data will be used both for DRAW and READ operations.
                
                STATIC suggests that the data will only be written once (or a small number of times).
                DYNAMIC suggests that the data will be used a small number of times before being 
                discarded.
                STREAM suggests that the data will be updated approximately every time that it is 
                used (that is, it will likely only be used once).
                
            target -- VBO target to which to bind (array or indices)
                GL_ARRAY_BUFFER -- array-data binding 
                GL_ELEMENT_ARRAY_BUFFER -- index-data binding
                GL_UNIFORM_BUFFER -- used to pass mid-size arrays of data packed into a buffer
                GL_TEXTURE_BUFFER -- used to pass large arrays of data as a pseudo-texture
                GL_TRANSFORM_FEEDBACK_BUFFER -- used to receive transformed vertices for processing
                
            size -- if not provided, will use arrayByteCount to determine the size of the data-array,
                thus this value (number of bytes) is required when using opaque data-structures,
                (such as ctypes pointers) as the array data-source.
            """
            ...
        
        _I_ = ...
        implementation = ...
        def resolve(self, value): # -> Any:
            """Resolve string constant to constant"""
            ...
        
        def set_array(self, data, size=...): # -> None:
            """Update our entire array with new data
            
            data -- PyOpenGL-compatible array-data structure, numpy arrays, ctypes arrays, etc.
            size -- if not provided, will use arrayByteCount to determine the size of the data-array,
                thus this value (number of bytes) is required when using opaque data-structures,
                (such as ctypes pointers) as the array data-source.
            """
            ...
        
        def __setitem__(self, slice, array): # -> None:
            """Set slice of data on the array and vbo (if copied already)

            slice -- the Python slice object determining how the data should
                be copied into the vbo/array
            array -- something array-compatible that will be used as the
                source of the data, note that the data-format will have to
                be the same as the internal data-array to work properly, if
                not, the amount of data copied will be wrong.

            This is a reasonably complex operation, it has to have all sorts
            of state-aware changes to correctly map the source into the low-level
            OpenGL view of the buffer (which is just bytes as far as the GL
            is concerned).
            """
            ...
        
        def __len__(self): # -> int:
            """Delegate length/truth checks to our data-array"""
            ...
        
        def __getattr__(self, key): # -> Any:
            """Delegate failing attribute lookups to our data-array"""
            ...
        
        def create_buffers(self): # -> list[Any]:
            """Create the internal buffer(s)"""
            ...
        
        def copy_data(self): # -> None:
            """Copy our data into the buffer on the GL side (if required)
            
            Ensures that the GL's version of the data in the VBO matches our 
            internal view of the data, either by copying the entire data-set 
            over with glBufferData or by updating the already-transferred 
            data with glBufferSubData.
            """
            ...
        
        def delete(self): # -> None:
            """Delete this buffer explicitly"""
            ...
        
        def __int__(self) -> int:
            """Get our VBO id"""
            ...
        
        def bind(self): # -> None:
            """Bind this buffer for use in vertex calls
            
            If we have not yet created our implementation-level VBO, then we 
            will create it before binding.  Once bound, calls self.copy_data()
            """
            ...
        
        def unbind(self): # -> None:
            """Unbind the buffer (make normal array operations active)"""
            ...
        
        def __add__(self, other): # -> VBOOffset:
            """Add an integer to this VBO (create a VBOOffset)"""
            ...
        
        __enter__ = ...
        def __exit__(self, exc_type=..., exc_val=..., exc_tb=...): # -> Literal[False]:
            """Context manager exit"""
            ...
        
    
    
    class VBOOffset:
        """Offset into a VBO instance 
        
        This class is normally instantiated by doing a my_vbo + int operation,
        it can be passed to VBO requiring operations and will generate the 
        appropriate integer offset value to be passed in.
        """
        def __init__(self, vbo, offset) -> None:
            """Initialize the offset with vbo and offset (unsigned integer)"""
            ...
        
        def __getattr__(self, key): # -> Any:
            """Delegate any undefined attribute save vbo to our vbo"""
            ...
        
        def __add__(self, other): # -> VBOOffset:
            """Allow adding integers or other VBOOffset instances 
            
            returns a VBOOffset to the this VBO with other.offset + self.offset
            or, if other has no offset, returns VBOOffset with self.offset + other
            """
            ...
        
    
    
    class VBOHandler(FormatHandler):
        """Handles VBO instances passed in as array data
        
        This FormatHandler is registered with PyOpenGL on import of this module 
        to provide handling of VBO objects as array data-sources
        """
        vp0 = ...
        def dataPointer(self, instance): # -> Literal[0]:
            """Retrieve data-pointer from the instance's data

            Is always NULL, to indicate use of the bound pointer
            """
            ...
        
        def from_param(self, instance, typeCode=...): # -> c_void_p:
            """Always returns c_void_p(0)"""
            ...
        
        def zeros(self, dims, typeCode):
            """Not implemented"""
            ...
        
        ones = ...
        def asArray(self, value, typeCode=...):
            """Given a value, convert to array representation"""
            ...
        
        def arrayToGLType(self, value):
            """Given a value, guess OpenGL type of the corresponding pointer"""
            ...
        
        def arrayByteCount(self, value):
            ...
        
        def arraySize(self, value, typeCode=...):
            """Given a data-value, calculate dimensions for the array"""
            ...
        
        def unitSize(self, value, typeCode=...):
            """Determine unit size of an array (if possible)"""
            ...
        
        def dimensions(self, value, typeCode=...):
            """Determine dimensions of the passed array value (if possible)"""
            ...
        
    
    
    class VBOOffsetHandler(VBOHandler):
        """Handles VBOOffset instances passed in as array data
        
        Registered on module import to provide support for VBOOffset instances 
        as sources for array data.
        """
        def dataPointer(self, instance):
            """Retrieve data-pointer from the instance's data

            returns instance' offset
            """
            ...
        
        def from_param(self, instance, typeCode=...): # -> c_void_p:
            """Returns a c_void_p( instance.offset )"""
            ...
        
    
    
_cleaners = ...
def mapVBO(vbo, access=...): # -> NDArray[Any]:
    """Map the given buffer into a numpy array...

    Method taken from:
     http://www.mail-archive.com/numpy-discussion@lists.sourceforge.net/msg01161.html

    This should be considered an *experimental* API,
    it is not guaranteed to be available in future revisions
    of this library!
    
    Simplification to use ctypes cast from comment by 'sashimi' on my blog...
    """
    ...

